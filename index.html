// ---------- CSF-based Low Vision Filter (Thompson et al. approach) ----------
  function srgbToLinear(u){ return (u<=0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4); }
  function linearToSrgb(u){ return (u<=0.0031308) ? (12.92*u) : (1.055*Math.pow(u,1/2.4)-0.055); }

  // Convert RGB to linear luminance
  function rgbaToLinearY(rgba){
    const Y = new cv.Mat(rgba.rows, rgba.cols, cv.CV_32F);
    const N = rgba.rows*rgba.cols; const src = rgba.data; const ydata = new Float32Array(Y.data.buffer);
    for(let j=0,i=0;j<N;j++,i+=4){
      const r = srgbToLinear(src[i]/255), g = srgbToLinear(src[i+1]/255), b = srgbToLinear(src[i+2]/255);
      ydata[j] = 0.2126*r + 0.7152*g + 0.0722*b;
    }
    return Y;
  }

  // Replace luminance while preserving chromaticity
  function replaceYKeepChroma(Ylin, rgbaIn){
    const out = new cv.Mat(rgbaIn.rows, rgbaIn.cols, rgbaIn.type());
    const N = rgbaIn.rows*rgbaIn.cols; const src = rgbaIn.data; const dst = out.data; const ynew = new Float32Array(Ylin.data.buffer);
    for(let j=0,i=0;j<N;j++,i+=4){
      let r = srgbToLinear(src[i]/255), g = srgbToLinear(src[i+1]/255), b = srgbToLinear(src[i+2]/255);
      const yold = 0.2126*r + 0.7152*g + 0.0722*b;
      const s = yold>1e-6 ? (ynew[j]/yold) : 0;
      r = Math.min(1, Math.max(0, r*s));
      g = Math.min(1, Math.max(0, g*s));
      b = Math.min(1, Math.max(0, b*s));
      dst[i]   = Math.round(255*linearToSrgb(r));
      dst[i+1] = Math.round(255*linearToSrgb(g));
      dst[i+2] = Math.round(255*linearToSrgb(b));
      dst[i+3] = src[i+3];
    }
    return out;
  }

  // Create Gaussian kernel
  function createGaussianKernel(sigma) {
    const size = Math.ceil(sigma * 3) * 2 + 1;
    const kernel = new cv.Mat(size, size, cv.CV_32F);
    const center = Math.floor(size / 2);
    let sum = 0;
    
    for (let i = 0; i < size; i++) {
      for (let j = 0; j < size; j++) {
        const x = i - center;
        const y = j - center;
        const value = Math.exp(-(x*x + y*y) / (2 * sigma * sigma));
        kernel.floatPtr(i, j)[0] = value;
        sum += value;
      }
    }
    
    // Normalize
    for (let i = 0; i < size; i++) {
      for (let j = 0; j < size; j++) {
        kernel.floatPtr(i, j)[0] /= sum;
      }
    }
    
    return kernel;
  }

  // Bandpass decomposition using Laplacian pyramid
  function pyrBuildLaplacian32(gray32, levels){
    const gP=[], lP=[];
    let cur=gray32.clone();
    for(let i=0;i<levels;i++){
      const down=new cv.Mat(); cv.pyrDown(cur,down);
      const up=new cv.Mat(); cv.pyrUp(down,up,cur.size());
      const lap=new cv.Mat(); cv.subtract(cur,up,lap);
      gP.push(cur); lP.push(lap);
      cur=down; up.delete();
    }
    gP.push(cur);
    return {gP,lP};
  }

  function pyrReconstruct32(lP, residual){
    let cur=residual.clone();
    for(let i=lP.length-1;i>=0;i--){
      const up=new cv.Mat(); cv.pyrUp(cur,up,lP[i].size());
      const sum=new cv.Mat(); cv.add(up,lP[i],sum);
      cur.delete(); cur=sum; up.delete();
    }
    return cur;
  }

  // Viewing geometry calculation
  function pxPerDeg(){
    const ppiEl=document.getElementById('ppi'), distEl=document.getElementById('viewDist');
    const ppi = ppiEl ? Number(ppiEl.value) : 96;
    const distCm = distEl ? Number(distEl.value) : 60;
    const pitchCm = 2.54/Math.max(1e-6, ppi);
    const degPerPx = (180/Math.PI) * (pitchCm/Math.max(1e-3, distCm));
    return 1/degPerPx; // pixels per degree
  }

  // Calculate center frequency for each pyramid level
  function bandCenter_cpd(i, levels, ppd){ 
    const cycPerPx = 0.5 / Math.pow(2, i);
    return cycPerPx * ppd; 
  }

  // CSF parameters from Thompson et al.
  function normalCSF(freq_cpd) {
    // Normal CSF approximation (Campbell & Robson style)
    const peak_freq = 3.0; // cycles per degree
    const peak_sensitivity = 200; // arbitrary units
    const falloff_low = 1.0;
    const falloff_high = 0.8;
    
    const ratio = freq_cpd / peak_freq;
    let sensitivity;
    
    if (ratio < 1) {
      sensitivity = peak_sensitivity * Math.pow(ratio, falloff_low);
    } else {
      sensitivity = peak_sensitivity * Math.pow(ratio, -falloff_high);
    }
    
    return Math.max(0.1, sensitivity);
  }

  // Calculate impaired CSF based on acuity and contrast sensitivity
  function impairedCSF(freq_cpd, logMAR, pellRobson) {
    const normalSens = normalCSF(freq_cpd);
    
    // Acuity affects high frequencies more
    const acuityFactor = Math.pow(10, -logMAR); // converts logMAR to Snellen decimal
    const highFreqCutoff = acuityFactor * 30; // approximate cutoff frequency
    
    // Contrast sensitivity affects overall gain
    const contrastFactor = Math.pow(10, pellRobson - 2.0); // normalize to normal vision
    
    // Combine effects
    let impairedSens = normalSens * contrastFactor;
    
    // Apply frequency-dependent acuity loss
    if (freq_cpd > highFreqCutoff) {
      const rolloff = Math.exp(-(freq_cpd - highFreqCutoff) / (highFreqCutoff * 0.5));
      impairedSens *= rolloff;
    }
    
    return Math.max(0.01, impairedSens);
  }

  // Calculate band gain (impaired CSF / normal CSF)
  function bandGain(f_cpd, logMAR, pellRobson){
    const normal = normalCSF(f_cpd);
    const impaired = impairedCSF(f_cpd, logMAR, pellRobson);
    return impaired / normal;
  }
