<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Visual Accessibility Prototype – Working Build</title>
  <style>
    :root { --bg:#f6f7fb; --fg:#111; --muted:#666; --pri:#2b6cb0; --card:#fff; }
    *{box-sizing:border-box} body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg)}
    header{padding:20px 16px} header h1{margin:0 0 6px;font-size:1.25rem}
    main{display:grid;grid-template-columns:1fr 1fr;gap:16px;padding:0 16px 24px}
    @media (max-width:1000px){ main{grid-template-columns:1fr} }
    .panel{background:var(--card);border-radius:14px;padding:14px;box-shadow: 0 1px 6px rgba(0,0,0,.06)}
    .panel h2{margin:0 0 10px;font-size:1.05rem}
    canvas{width:100%;height:auto;background:#222;border-radius:10px}
    details{margin-top:10px}
    .tool-row{display:flex;gap:14px;flex-wrap:wrap}
    .tool{flex:1;min-width:240px}
    label{display:block;margin:6px 0;color:#222}
    input[type="range"]{width:100%}
    .button{background:var(--pri);color:#fff;border:none;border-radius:10px;padding:8px 12px;cursor:pointer}
    .button.secondary{background:#444}
    .uploader{border:2px dashed #bbb;border-radius:12px;padding:16px;text-align:center;background:#fbfbfb}
    .uploader.dragover{background:#eef7ff;border-color:#339}
    #fileInput{display:none}
    #status{margin-top:10px;font-size:0.95rem;color:#333;white-space:pre-wrap}
    small{display:block;color:#555}
  </style>
</head>
<body>
  <header>
    <h1>Visual Accessibility Prototype – Working Build</h1>
    <p>Upload a photo or render. All processing runs locally in your browser.</p>
  </header>

  <main>
    <section class="panel">
      <h2>Original</h2>
      <div class="uploader" id="dropArea" aria-label="Drop image here">
        <p><strong>Drop image here</strong> or <label for="fileInput" class="button">Choose a file</label></p>
        <input id="fileInput" type="file" accept="image/*"/>
        <small>PNG/JPG recommended • Large images are auto-downscaled for performance</small>
      </div>
      <canvas id="orig"></canvas>
    </section>

    <section class="panel">
      <h2>Processed</h2>
      <canvas id="proc"></canvas>
    </section>
  </main>

  <section class="panel" style="margin:0 16px 24px">
    <details open>
      <summary><strong>Acuity & Contrast (CSF-based pipeline)</strong></summary>
      <div class="tool-row">
        <div class="tool">
          <h3>Acuity (logMAR)</h3>
          <label>logMAR: <span id="logmarVal">0.00</span> <small>Snellen: <span id="snellen">20/20</span></small></label>
          <input id="logmar" type="range" min="0.0" max="1.2" step="0.05" value="0.00"/>
        </div>
        <div class="tool">
          <h3>Contrast (Pelli–Robson)</h3>
          <label>PR: <span id="prVal">1.40</span></label>
          <input id="pr" type="range" min="0.0" max="2.0" step="0.05" value="1.40"/>
        </div>
      </div>
      <div class="tool-row">
        <div class="tool">
          <h3>Model Settings</h3>
          <label>Levels: <span id="levelsVal">4</span></label>
          <input id="levels" type="range" min="3" max="6" step="1" value="4"/>
          <label>Strength: <span id="strengthVal">1.00</span></label>
          <input id="strength" type="range" min="0.0" max="1.0" step="0.05" value="1.00"/>
          <label style="display:block;margin-top:8px;"><input type="checkbox" id="autoCSF" checked/> Auto-apply when sliders change</label>
          <details>
            <summary>Advanced: Viewing Geometry</summary>
            <label>Screen PPI: <input id="ppi" type="number" value="96"/></label>
            <label>Viewing distance (cm): <input id="viewDist" type="number" value="60"/></label>
          </details>
          <button id="applyCSF" class="button secondary">Apply CSF Filter</button>
          <small id="csfInfo"></small>
        </div>
      </div>
    </details>

    <details>
      <summary><strong>Lens yellowing & Global contrast</strong></summary>
      <div class="tool-row">
        <div class="tool">
          <h3>Lens yellowing</h3>
          <label>Amount: <span id="yellVal">0</span>%</label>
          <input id="yellowing" type="range" min="0" max="100" step="5" value="0"/>
          <button id="applyYellow" class="button secondary">Apply Yellowing</button>
        </div>
        <div class="tool">
          <h3>Global contrast</h3>
          <label>±: <span id="contrastVal">0</span>%</label>
          <input id="contrast" type="range" min="-50" max="50" step="5" value="0"/>
          <button id="applyContrast" class="button secondary">Apply Contrast</button>
        </div>
      </div>
    </details>

    <details>
      <summary><strong>Scotoma & Demos</strong></summary>
      <div class="tool-row">
        <div class="tool">
          <h3>Scotoma</h3>
          <label>Size: <span id="scSizeVal">20</span>%</label>
          <input id="scSize" type="range" min="5" max="60" step="1" value="20"/>
          <label>Feather: <span id="scFeatherVal">20</span></label>
          <input id="scFeather" type="range" min="0" max="50" step="1" value="20"/>
          <button id="applyScotoma" class="button secondary">Apply Scotoma</button>
        </div>
        <div class="tool">
          <h3>Canny edges (demo)</h3>
          <label>T1 <input id="canny1" type="number" min="0" max="255" value="80"/></label>
          <label>T2 <input id="canny2" type="number" min="0" max="255" value="160"/></label>
          <button id="applyCanny" class="button secondary">Edges</button>
        </div>
        <div class="tool">
          <h3>Gaussian blur (demo)</h3>
          <label>σ: <span id="blurVal">3</span></label>
          <input id="blur" type="range" min="0" max="15" step="0.5" value="3"/>
          <button id="applyBlur" class="button secondary">Apply Blur</button>
        </div>
      </div>
    </details>

    <div class="tool-row" style="margin-top:10px">
      <button id="reset" class="button">Reset</button>
      <button id="download" class="button">Download PNG</button>
      <span id="status" style="margin-left:8px"></span>
    </div>
  </section>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
  let origMat=null, procMat=null, origCanvas=null, procCanvas=null, statusEl=null;
  let maxPixels=3000000;
  function setStatus(msg){ statusEl && (statusEl.textContent = String(msg||'')); }
  function onCvReady(){ setStatus('OpenCV.js loaded.'); }
  if (window.cv && cv['onRuntimeInitialized']===undefined) { cv['onRuntimeInitialized']=onCvReady; }
  else { document.addEventListener('opencvready', onCvReady); }

  function fitCanvasToImage(canvas,w,h){
    const px=w*h;
    if(px>maxPixels){ const s=Math.sqrt(maxPixels/px); w=Math.round(w*s); h=Math.round(h*s); }
    canvas.width=w; canvas.height=h;
  }
  function loadImage(file){
    return new Promise((resolve,reject)=>{
      if(!file || !file.type || !file.type.startsWith('image/')) return reject(new Error('Please choose an image file.'));
      const img=new Image();
      img.onload=()=>resolve(img);
      img.onerror=()=>reject(new Error('Could not read image.'));
      img.src=URL.createObjectURL(file);
    });
  }
  async function handleFile(file){
    try{
      setStatus('Loading image...');
      const img=await loadImage(file);
      fitCanvasToImage(origCanvas, img.naturalWidth||img.width, img.naturalHeight||img.height);
      const ctx=origCanvas.getContext('2d');
      ctx.clearRect(0,0,origCanvas.width,origCanvas.height);
      ctx.drawImage(img,0,0,origCanvas.width,origCanvas.height);
      if(origMat) origMat.delete(); if(procMat) procMat.delete();
      origMat = cv.matFromImageData(ctx.getImageData(0,0,origCanvas.width,origCanvas.height));
      procMat = origMat.clone();
      cv.imshow('proc', procMat);
      setStatus(`Loaded ${file.name} (${img.width}×${img.height} → ${origCanvas.width}×${origCanvas.height})`);
    }catch(e){ setStatus(e.message||'Failed to load image.'); }
  }
  function resetProcessed(){ if(!origMat) return; if(procMat) procMat.delete(); procMat=origMat.clone(); cv.imshow('proc', procMat); setStatus('Reset.'); }

  // ---------- CSF-based Low Vision Filter (Thompson et al. approach) ----------
  function srgbToLinear(u){ return (u<=0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4); }
  function linearToSrgb(u){ return (u<=0.0031308) ? (12.92*u) : (1.055*Math.pow(u,1/2.4)-0.055); }

  // Convert RGB to linear luminance
  function rgbaToLinearY(rgba){
    const Y = new cv.Mat(rgba.rows, rgba.cols, cv.CV_32F);
    const N = rgba.rows*rgba.cols; const src = rgba.data; const ydata = new Float32Array(Y.data.buffer);
    for(let j=0,i=0;j<N;j++,i+=4){
      const r = srgbToLinear(src[i]/255), g = srgbToLinear(src[i+1]/255), b = srgbToLinear(src[i+2]/255);
      ydata[j] = 0.2126*r + 0.7152*g + 0.0722*b;
    }
    return Y;
  }

  // Replace luminance while preserving chromaticity
  function replaceYKeepChroma(Ylin, rgbaIn){
    const out = new cv.Mat(rgbaIn.rows, rgbaIn.cols, rgbaIn.type());
    const N = rgbaIn.rows*rgbaIn.cols; const src = rgbaIn.data; const dst = out.data; const ynew = new Float32Array(Ylin.data.buffer);
    for(let j=0,i=0;j<N;j++,i+=4){
      let r = srgbToLinear(src[i]/255), g = srgbToLinear(src[i+1]/255), b = srgbToLinear(src[i+2]/255);
      const yold = 0.2126*r + 0.7152*g + 0.0722*b;
      const s = yold>1e-6 ? (ynew[j]/yold) : 0;
      r = Math.min(1, Math.max(0, r*s));
      g = Math.min(1, Math.max(0, g*s));
      b = Math.min(1, Math.max(0, b*s));
      dst[i]   = Math.round(255*linearToSrgb(r));
      dst[i+1] = Math.round(255*linearToSrgb(g));
      dst[i+2] = Math.round(255*linearToSrgb(b));
      dst[i+3] = src[i+3];
    }
    return out;
  }

  // Bandpass decomposition using Laplacian pyramid
  function pyrBuildLaplacian32(gray32, levels){
    const gP=[], lP=[];
    let cur=gray32.clone();
    for(let i=0;i<levels;i++){
      const down=new cv.Mat(); cv.pyrDown(cur,down);
      const up=new cv.Mat(); cv.pyrUp(down,up,cur.size());
      const lap=new cv.Mat(); cv.subtract(cur,up,lap);
      gP.push(cur); lP.push(lap);
      cur=down; up.delete();
    }
    gP.push(cur);
    return {gP,lP};
  }

  function pyrReconstruct32(lP, residual){
    let cur=residual.clone();
    for(let i=lP.length-1;i>=0;i--){
      const up=new cv.Mat(); cv.pyrUp(cur,up,lP[i].size());
      const sum=new cv.Mat(); cv.add(up,lP[i],sum);
      cur.delete(); cur=sum; up.delete();
    }
    return cur;
  }

  // Viewing geometry calculation
  function pxPerDeg(){
    const ppiEl=document.getElementById('ppi'), distEl=document.getElementById('viewDist');
    const ppi = ppiEl ? Number(ppiEl.value) : 96;
    const distCm = distEl ? Number(distEl.value) : 60;
    const pitchCm = 2.54/Math.max(1e-6, ppi);
    const degPerPx = (180/Math.PI) * (pitchCm/Math.max(1e-3, distCm));
    return 1/degPerPx; // pixels per degree
  }

  // Calculate center frequency for each pyramid level
  function bandCenter_cpd(i, levels, ppd){ 
    const cycPerPx = 0.5 / Math.pow(2, i);
    return cycPerPx * ppd; 
  }

  // CSF parameters from Thompson et al.
  function normalCSF(freq_cpd) {
    // Normal CSF approximation (Campbell & Robson style)
    const peak_freq = 3.0; // cycles per degree
    const peak_sensitivity = 200; // arbitrary units
    const falloff_low = 1.0;
    const falloff_high = 0.8;
    
    const ratio = freq_cpd / peak_freq;
    let sensitivity;
    
    if (ratio < 1) {
      sensitivity = peak_sensitivity * Math.pow(ratio, falloff_low);
    } else {
      sensitivity = peak_sensitivity * Math.pow(ratio, -falloff_high);
    }
    
    return Math.max(0.1, sensitivity);
  }

  // Calculate impaired CSF based on acuity and contrast sensitivity
  function impairedCSF(freq_cpd, logMAR, pellRobson) {
    const normalSens = normalCSF(freq_cpd);
    
    // Acuity affects high frequencies more
    const acuityFactor = Math.pow(10, -logMAR); // converts logMAR to Snellen decimal
    const highFreqCutoff = acuityFactor * 30; // approximate cutoff frequency
    
    // Contrast sensitivity affects overall gain
    const contrastFactor = Math.pow(10, pellRobson - 2.0); // normalize to normal vision
    
    // Combine effects
    let impairedSens = normalSens * contrastFactor;
    
    // Apply frequency-dependent acuity loss
    if (freq_cpd > highFreqCutoff) {
      const rolloff = Math.exp(-(freq_cpd - highFreqCutoff) / (highFreqCutoff * 0.5));
      impairedSens *= rolloff;
    }
    
    return Math.max(0.01, impairedSens);
  }

  // Calculate band gain (impaired CSF / normal CSF)
  function bandGain(f_cpd, logMAR, pellRobson){
    const normal = normalCSF(f_cpd);
    const impaired = impairedCSF(f_cpd, logMAR, pellRobson);
    return impaired / normal;
  }

  function applyCSF(logMAR, PR, levels, strength){
    if(!procMat){ setStatus('Load an image first.'); return; }
    setStatus('Applying CSF filter...');
    
    try {
      // Convert to linear luminance
      const Ylin = rgbaToLinearY(procMat);
      const Y32 = new cv.Mat(); Ylin.convertTo(Y32, cv.CV_32F, 1.0);
      
      // Build Laplacian pyramid for frequency decomposition
      const pyr = pyrBuildLaplacian32(Y32, levels);
      
      // Get viewing parameters
      const ppd = pxPerDeg();
      
      let gainsInfo = [];
      
      // Apply CSF-based gains to each frequency band
      for(let i = 0; i < pyr.lP.length; i++){
        const f = bandCenter_cpd(i, pyr.lP.length, ppd);
        const gain = (1-strength) + strength * bandGain(f, logMAR, PR);
        gainsInfo.push(`${f.toFixed(2)}c/deg→${gain.toFixed(2)}`);
        
        // Apply gain to this frequency band
        cv.multiply(pyr.lP[i], new cv.Scalar(gain), pyr.lP[i]);
      }
      
      // Reconstruct image from modified pyramid
      const Yrec = pyrReconstruct32(pyr.lP, pyr.gP[pyr.gP.length-1]);
      
      // Clamp values to valid range
      cv.min(Yrec, new cv.Scalar(1), Yrec); 
      cv.max(Yrec, new cv.Scalar(0), Yrec);
      
      // Convert back to RGBA, preserving chromaticity
      const outRGBA = replaceYKeepChroma(Yrec, procMat);
      
      // Update processed image
      procMat.delete(); 
      procMat = outRGBA; 
      cv.imshow('proc', procMat);
      
      // Clean up temporary matrices
      [Ylin, Y32, Yrec].forEach(m => m.delete());
      pyr.gP.forEach(m => m.delete());
      pyr.lP.forEach(m => m.delete());
      
      // Update status and info
      const infoEl = document.getElementById('csfInfo');
      if(infoEl){
        infoEl.textContent = `Bands: ${gainsInfo.join(' • ')} | ppd≈${ppd.toFixed(1)} | logMAR=${logMAR.toFixed(2)} PR=${PR.toFixed(2)}`;
      }
      
      setStatus(`CSF filter applied (${levels} levels, strength=${strength.toFixed(2)})`);
      
    } catch(e) {
      setStatus('Error applying CSF filter: ' + e.message);
      console.error('CSF filter error:', e);
    }
  }

  // ---------- Other effects ----------
  function applyBlur(px){
    if(!procMat) return;
    const out=new cv.Mat();
    const k=Math.max(1,(Math.floor(px)|1));
    cv.GaussianBlur(procMat,out,new cv.Size(k,k),0,0,cv.BORDER_DEFAULT);
    procMat.delete(); procMat=out; cv.imshow('proc', procMat);
  }
  function applyCanny(t1,t2){
    if(!procMat) return;
    const gray=new cv.Mat(); cv.cvtColor(procMat,gray,cv.COLOR_RGBA2GRAY,0);
    const edges=new cv.Mat(); cv.Canny(gray,edges,Number(t1),Number(t2),3,false);
    const disp=new cv.Mat(); cv.cvtColor(edges,disp,cv.COLOR_GRAY2RGBA,0);
    procMat.delete(); procMat=disp; cv.imshow('proc', procMat);
    gray.delete(); edges.delete();
  }
  function applyYellowing(percent){
    if(!procMat) return;
    const f = Math.max(0, Math.min(1, percent/100));
    const out = new cv.Mat(procMat.rows, procMat.cols, procMat.type());
    const src = procMat.data, dst = out.data;
    for(let i=0;i<src.length;i+=4){
      const r=src[i], g=src[i+1], b=src[i+2];
      // simple yellowing: reduce blue, mildly lift red/green
      const b2 = Math.round(b*(1-0.7*f));
      const r2 = Math.min(255, Math.round(r*(1+0.15*f)));
      const g2 = Math.min(255, Math.round(g*(1+0.10*f)));
      dst[i]=r2; dst[i+1]=g2; dst[i+2]=b2; dst[i+3]=src[i+3];
    }
    procMat.delete(); procMat=out; cv.imshow('proc', procMat);
  }
  function applyGlobalContrast(percent){
    if(!procMat) return;
    // percent ∈ [-50,50]; map to alpha and beta
    const p = Math.max(-50, Math.min(50, percent));
    const alpha = 1 + (p/100)*2; // 0→1, 50→2
    const beta = 0; // no bias
    const out=new cv.Mat(); procMat.convertTo(out, -1, alpha, beta);
    procMat.delete(); procMat=out; cv.imshow('proc', procMat);
  }
  function applyScotoma(sizePct, feather){
    if(!procMat) return;
    const w=procMat.cols, h=procMat.rows;
    const cx=Math.round(w/2), cy=Math.round(h/2);
    const r = Math.round(Math.min(w,h)*sizePct/200); // radius
    const mask=new cv.Mat.zeros(h,w,cv.CV_32F);
    // radial feathered mask 0..1 (1 inside scotoma)
    for(let y=0; y<h; y++){
      for(let x=0; x<w; x++){
        const dx=x-cx, dy=y-cy; const d=Math.sqrt(dx*dx+dy*dy);
        let m = d<=r ? 1 : 0;
        if (feather>0){
          const f = feather;
          if(d>r && d<r+f) m = 1 - (d-r)/f;
        }
        mask.floatPtr(y,x)[0]=m;
      }
    }
    const inv=new cv.Mat(); cv.subtract(cv.Mat.ones(h,w,cv.CV_32F), mask, inv);
    const src32=new cv.Mat(); procMat.convertTo(src32, cv.CV_32FC4, 1/255);
    const fg=new cv.Mat(), bg=new cv.Mat();
    cv.multiply(src32,new cv.Mat(src32.rows,src32.cols,cv.CV_32FC4,new cv.Scalar(0,0,0,1)),bg);
    // apply mask to combine
    const ch=new cv.MatVector(); cv.split(src32,ch);
    const m4=new cv.MatVector(); m4.push_back(mask); m4.push_back(mask); m4.push_back(mask); m4.push_back(mask);
    const masked=new cv.MatVector();
    for(let i=0;i<4;i++){ const tmp=new cv.Mat(); cv.multiply(ch.get(i), m4.get(i), tmp); masked.push_back(tmp); }
    const sc=new cv.Mat(); cv.merge(masked, sc);
    const keep=new cv.MatVector();
    for(let i=0;i<4;i++){ const tmp=new cv.Mat(); cv.multiply(ch.get(i), inv, tmp); keep.push_back(tmp); }
    const kept=new cv.Mat(); cv.merge(keep, kept);
    const sum=new cv.Mat(); cv.add(kept, sc, sum);
    const out=new cv.Mat(); sum.convertTo(out, cv.CV_8UC4, 255);
    procMat.delete(); procMat=out; cv.imshow('proc', procMat);
    // cleanup
    [mask,inv,src32,fg,bg,sc,kept,sum].forEach(m=>m.delete());
    for(let i=0;i<4;i++){ ch.get(i).delete(); masked.get(i).delete(); keep.get(i).delete(); }
    ch.delete(); masked.delete(); keep.delete(); m4.get(0).delete(); m4.get(1).delete(); m4.get(2).delete(); m4.get(3).delete(); m4.delete();
  }

  // ---------- Wiring ----------
  window.addEventListener('DOMContentLoaded',()=>{
    origCanvas=document.getElementById('orig'); procCanvas=document.getElementById('proc'); statusEl=document.getElementById('status');
    const fileInput=document.getElementById('fileInput'); const dropArea=document.getElementById('dropArea');
    fileInput.addEventListener('change', e=>{ const f=e.target.files[0]; if(f) handleFile(f); });
    ['dragenter','dragover','dragleave','drop'].forEach(evt=>dropArea.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); }, false));
    ['dragenter','dragover'].forEach(evt=>dropArea.addEventListener(evt, ()=>dropArea.classList.add('dragover'), false));
    ['dragleave','drop'].forEach(evt=>dropArea.addEventListener(evt, ()=>dropArea.classList.remove('dragover'), false));
    dropArea.addEventListener('drop', e=>{ const f=e.dataTransfer.files && e.dataTransfer.files[0]; if(f) handleFile(f); });

    const logmar=document.getElementById('logmar'), logmarVal=document.getElementById('logmarVal'), snellen=document.getElementById('snellen');
    const pr=document.getElementById('pr'), prVal=document.getElementById('prVal');
    const levels=document.getElementById('levels'), levelsVal=document.getElementById('levelsVal');
    const strength=document.getElementById('strength'), strengthVal=document.getElementById('strengthVal');
    const applyCSFBtn=document.getElementById('applyCSF');
    const autoCSF=document.getElementById('autoCSF');

    function snellenFromLogMAR(lv){ const s=Math.pow(10,-lv); const den=Math.round(20/s); return `20/${den}`; }
    function labels(){
      const lv=Number(logmar.value); logmarVal.textContent=lv.toFixed(2); snellen.textContent=snellenFromLogMAR(lv);
      prVal.textContent=Number(pr.value).toFixed(2);
      levelsVal.textContent=levels.value; strengthVal.textContent=Number(strength.value).toFixed(2);
    }
    function applyIfAuto(){
      if(autoCSF && autoCSF.checked){
        resetProcessed();
        applyCSF(Number(logmar.value), Number(pr.value), Number(levels.value), Number(strength.value));
      }
    }
    labels();
    [logmar,pr,levels,strength].forEach(el=>el.addEventListener('input', ()=>{ labels(); applyIfAuto(); }));
    applyCSFBtn.addEventListener('click', ()=>applyCSF(Number(logmar.value), Number(pr.value), Number(levels.value), Number(strength.value)));

    const blur=document.getElementById('blur'), blurVal=document.getElementById('blurVal');
    document.getElementById('applyBlur').addEventListener('click', ()=>applyBlur(Number(blur.value)));
    blur.addEventListener('input', ()=>{ blurVal.textContent=blur.value; });

    const canny1=document.getElementById('canny1'), canny2=document.getElementById('canny2');
    document.getElementById('applyCanny').addEventListener('click', ()=>applyCanny(Number(canny1.value), Number(canny2.value)));

    const yellowing=document.getElementById('yellowing'), yellVal=document.getElementById('yellVal');
    document.getElementById('applyYellow').addEventListener('click', ()=>applyYellowing(Number(yellowing.value)));
    yellowing.addEventListener('input', ()=>{ yellVal.textContent=yellowing.value; });

    const contrast=document.getElementById('contrast'), contrastVal=document.getElementById('contrastVal');
    document.getElementById('applyContrast').addEventListener('click', ()=>applyGlobalContrast(Number(contrast.value)));
    contrast.addEventListener('input', ()=>{ contrastVal.textContent=contrast.value; });

    const scSize=document.getElementById('scSize'), scSizeVal=document.getElementById('scSizeVal');
    const scFeather=document.getElementById('scFeather'), scFeatherVal=document.getElementById('scFeatherVal');
    document.getElementById('applyScotoma').addEventListener('click', ()=>applyScotoma(Number(scSize.value), Number(scFeather.value)));
    scSize.addEventListener('input', ()=>{ scSizeVal.textContent=scSize.value; });
    scFeather.addEventListener('input', ()=>{ scFeatherVal.textContent=scFeather.value; });

    document.getElementById('reset').addEventListener('click', resetProcessed);
    document.getElementById('download').addEventListener('click', ()=>{
      const proc=document.getElementById('proc'); const link=document.createElement('a');
      link.download='processed.png'; link.href=proc.toDataURL('image/png'); link.click();
    });
  });
  </script>
</body>
</html>