<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Seeing Home Through Older Eyes — CSF Prototype v3</title>
  <style>
  *{box-sizing:border-box}body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;margin:0;color:#111;background:#fafafa}
  header{padding:24px 16px;background:#fff;border-bottom:1px solid #eee}
  h1{margin:0 0 8px 0;font-size:22px}
  main{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px}
  .panel{background:#fff;border:1px solid #eee;border-radius:16px;padding:16px}
  summary{cursor:pointer}
  .tool-row{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
  .tool{flex:1 1 160px;background:#f9f9f9;border:1px solid #eee;border-radius:12px;padding:12px}
  .button{display:inline-block;background:#111;color:#fff;border:none;border-radius:12px;padding:8px 12px;cursor:pointer}
  .button.secondary{background:#444}
  .viewer{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  canvas{max-width:100%;width:100%;background:#ddd;border-radius:8px}
  label{display:block;margin:6px 0}
  small{display:block;color:#555}
  .uploader{border:2px dashed #bbb;border-radius:12px;padding:16px;text-align:center;background:#fbfbfb}
  .uploader.dragover{background:#eef7ff;border-color:#339}
  #fileInput{display:none}
  #status{margin-top:10px;font-size:0.95rem;color:#333;white-space:pre-wrap}
  .perf{background:#fff;border:1px dashed #ddd;border-radius:12px;padding:12px;margin-top:12px}
  </style>
</head>
<body>
  <header>
    <h1>Seeing Home Through Older Eyes — CSF-based Prototype (v3)</h1>
    <p>Upload a photo or render. All processing runs locally in your browser.</p>
  </header>

  <main>
    <section class="panel">
      <div class="uploader" id="dropArea" aria-label="Drop image here">
        <p><strong>Drop image here</strong> or <label for="fileInput" class="button">Choose a file</label></p>
        <input id="fileInput" type="file" accept="image/*"/>
        <small>PNG/JPG recommended • Large images are auto-downscaled for performance</small>
      </div>

      <div class="perf">
        <label for="maxPixels">Max processing size: <span id="maxPixelsLabel">3 MP</span></label>
        <input id="maxPixels" type="range" min="1" max="8" step="1" value="3"/>
        <small>Higher = sharper but slower. The cap is applied at load time.</small>
      </div>

      <details open>
        <summary><strong>CSF Visibility Model (prototype)</strong></summary>
        <div class="tool-row">
          <div class="tool">
            <h3>Acuity (logMAR)</h3>
            <label>logMAR: <span id="logmarVal">0.60</span> &nbsp; Snellen: <span id="snellen">~20/80</span></label>
            <input id="logmar" type="range" min="0" max="1.0" step="0.05" value="0.60"/>
          </div>
          <div class="tool">
            <h3>Contrast (Pelli–Robson)</h3>
            <label>PR: <span id="prVal">1.40</span></label>
            <input id="pr" type="range" min="0.0" max="2.0" step="0.05" value="1.40"/>
          </div>
        </div>
        <div class="tool-row">
          <div class="tool">
            <h3>Model Settings</h3>
            <label>Levels: <span id="levelsVal">4</span></label>
            <input id="levels" type="range" min="3" max="6" step="1" value="4"/>
            <label>Strength: <span id="strengthVal">1.00</span></label>
            <input id="strength" type="range" min="0.0" max="1.0" step="0.05" value="1.00"/>
            <label>Screen PPI: <input id="ppi" type="number" value="96"/></label>
            <label>Viewing distance (cm): <input id="viewDist" type="number" value="60"/></label>

            
            <button id="applyCSF" class="button secondary">Apply CSF Filter</button>
          </div>
        </div>
        <small id="csfInfo"></small>
      </details>

      <details>
        <summary><strong>Acuity & Edges (demos)</strong></summary>
        <div class="tool-row">
          <div class="tool">
            <h3>Gaussian blur (px)</h3>
            <label>σ: <span id="blurVal">3</span></label>
            <input id="blur" type="range" min="0" max="15" step="0.5" value="3"/>
            <button id="applyBlur" class="button secondary">Apply Blur</button>
          </div>
          <div class="tool">
            <h3>Canny edges</h3>
            <label>T1 <input id="canny1" type="number" min="0" max="255" value="80"/></label>
            <label>T2 <input id="canny2" type="number" min="0" max="255" value="160"/></label>
            <button id="applyCanny" class="button secondary">Run Edges</button>
          </div>
        </div>
      </details>

      <details>
        <summary><strong>Lens & Field Effects</strong></summary>
        <div class="tool-row">
          <div class="tool">
            <h3>Lens yellowing</h3>
            <label>Intensity: <span id="yellowVal">60%</span></label>
            <input id="yellow" type="range" min="0" max="100" step="5" value="60"/>
            <button id="applyYellow" class="button secondary">Apply Yellowing</button>
          </div>
          <div class="tool">
            <h3>Global contrast</h3>
            <label>Reduce: <span id="contrastVal">15%</span></label>
            <input id="contrast" type="range" min="0" max="50" step="5" value="15"/>
            <button id="applyContrast" class="button secondary">Reduce Contrast</button>
          </div>
          <div class="tool">
            <h3>Central scotoma</h3>
            <label>Radius (% min dim): <span id="scSizeVal">15%</span></label>
            <input id="scSize" type="range" min="0" max="40" step="1" value="15"/>
            <label>Feather (px): <span id="scFeatherVal">40</span></label>
            <input id="scFeather" type="range" min="0" max="100" step="5" value="40"/>
            <button id="applyScotoma" class="button secondary">Apply Scotoma</button>
          </div>
        </div>
      </details>

      <div class="tool-row" style="margin-top:12px">
        <div class="tool">
          <h3>Reset & Download</h3>
          <button id="reset" class="button">Reset to Original</button>
          <button id="download" class="button">Download Processed</button>
        </div>
      </div>

      <div id="status" role="status" aria-live="polite"></div>
    </section>

    <section class="viewer">
      <div class="panel">
        <h2>Original</h2>
        <canvas id="orig"></canvas>
      </div>
      <div class="panel">
        <h2>Processed</h2>
        <canvas id="proc"></canvas>
      </div>
    </section>
  </main>

  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="cv['onRuntimeInitialized']=onCvReady;"></script>
  <script>
  let origMat=null, procMat=null, origCanvas=null, procCanvas=null, statusEl=null;
  let maxPixels=3_000_000;

  function setStatus(msg){ statusEl.textContent = msg || ''; }
  function snellenFromLogMAR(v){ return '~20/' + Math.round(20*Math.pow(10,v)); }
  function onCvReady(){ setStatus('OpenCV.js is ready.'); }

  function fitCanvasToImage(canvas,w,h){
    const px=w*h;
    if(px>maxPixels){ const s=Math.sqrt(maxPixels/px); w=Math.round(w*s); h=Math.round(h*s); }
    canvas.width=w; canvas.height=h;
  }

  function loadImage(file){
    return new Promise((resolve,reject)=>{
      if(!file || !file.type.startsWith('image/')) return reject(new Error('Please choose an image file.'));
      const img=new Image(); img.onload=()=>resolve(img); img.onerror=()=>reject(new Error('Could not read image.')); img.src=URL.createObjectURL(file);
    });
  }

  async function handleFile(file){
    try{
      setStatus('Loading image...');
      const img=await loadImage(file);
      fitCanvasToImage(origCanvas, img.width, img.height);
      const ctx=origCanvas.getContext('2d'); ctx.clearRect(0,0,origCanvas.width,origCanvas.height); ctx.drawImage(img,0,0,origCanvas.width,origCanvas.height);
      if(origMat) origMat.delete(); if(procMat) procMat.delete();
      origMat = cv.matFromImageData(ctx.getImageData(0,0,origCanvas.width,origCanvas.height));
      procMat = origMat.clone();
      cv.imshow('proc', procMat);
      setStatus(`Loaded ${file.name} (${img.width}×${img.height} → ${origCanvas.width}×${origCanvas.height})`);
    }catch(e){ setStatus(e.message||'Failed to load image.'); }
  }

  function resetProcessed(){ if(!origMat) return; if(procMat) procMat.delete(); procMat=origMat.clone(); cv.imshow('proc', procMat); setStatus('Reset.'); }

  // ---------- CSF float pipeline ----------
  function toYCrCb(mat){ const ycc=new cv.Mat(); cv.cvtColor(mat,ycc,cv.COLOR_RGBA2YCrCb,0); return ycc; }
  function fromYCrCb(ycc){ const out=new cv.Mat(); cv.cvtColor(ycc,out,cv.COLOR_YCrCb2RGBA,0); return out; }
  function split3(m){ const mv=new cv.MatVector(); cv.split(m,mv); return {Y:mv.get(0),Cr:mv.get(1),Cb:mv.get(2),mv}; }
  function merge3(a,b,c){ const mv=new cv.MatVector(); mv.push_back(a); mv.push_back(b); mv.push_back(c); const out=new cv.Mat(); cv.merge(mv,out); mv.delete(); return out; }

  function pyrBuildLaplacian32(gray32, levels){
    const gP=[], lP=[];
    let cur=gray32.clone();
    for(let i=0;i<levels;i++){
      const down=new cv.Mat(); cv.pyrDown(cur,down);
      const up=new cv.Mat(); cv.pyrUp(down,up,cur.size());
      const lap=new cv.Mat(); cv.subtract(cur,up,lap);
      gP.push(cur); lP.push(lap);
      cur=down; up.delete();
    }
    gP.push(cur);
    return {gP,lP};
  }
  function pyrReconstruct32(lP, low){
    let cur=low.clone();
    for(let i=lP.length-1;i>=0;i--){
      const up=new cv.Mat(); cv.pyrUp(cur,up,lP[i].size());
      const sum=new cv.Mat(); cv.add(up,lP[i],sum);
      cur.delete(); cur=sum; up.delete();
    }
    return cur;
  }

  
  // ===== NEW: Viewing geometry, linear color, and Thompson/Chung–Legge CSF math =====
  function pxPerDeg(){
    const ppiEl=document.getElementById('ppi'), distEl=document.getElementById('viewDist');
    const ppi = ppiEl ? Number(ppiEl.value) : 96;
    const distCm = distEl ? Number(distEl.value) : 60;
    const pitchCm = 2.54/Math.max(1e-6, ppi);
    const degPerPx = (180/Math.PI) * (pitchCm/Math.max(1e-3, distCm));
    return 1/degPerPx;
  }
  function bandCenter_cpd(i, levels, pxPerDeg){
    const cycPerPx = 0.5 / Math.pow(2, i+0.5); // Nyquist/2^{i+0.5}
    return cycPerPx * pxPerDeg;
  }
  function srgbToLinear(u){ return (u<=0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4); }
  function linearToSrgb(u){ return (u<=0.0031308) ? (12.92*u) : (1.055*Math.pow(u,1/2.4)-0.055); }

  function rgbaToLinearY(rgba){ // cv.Mat RGBA -> single-channel CV_32F linear luminance
    const Y = new cv.Mat(rgba.rows, rgba.cols, cv.CV_32F);
    const N = rgba.rows*rgba.cols;
    const src = rgba.data; const ydata = new Float32Array(Y.data.buffer);
    for(let j=0,i=0;j<N;j++,i+=4){
      const r = srgbToLinear(src[i]/255);
      const g = srgbToLinear(src[i+1]/255);
      const b = srgbToLinear(src[i+2]/255);
      ydata[j] = 0.2126*r + 0.7152*g + 0.0722*b;
    }
    return Y;
  }

  function replaceYKeepChroma(Ylin, rgbaIn){
    const out = new cv.Mat(rgbaIn.rows, rgbaIn.cols, rgbaIn.type());
    const N = rgbaIn.rows*rgbaIn.cols;
    const src = rgbaIn.data; const dst = out.data;
    const ynew = new Float32Array(Ylin.data.buffer);
    for(let j=0,i=0;j<N;j++,i+=4){
      let r = srgbToLinear(src[i]/255), g = srgbToLinear(src[i+1]/255), b = srgbToLinear(src[i+2]/255);
      const yold = 0.2126*r + 0.7152*g + 0.0722*b;
      const s = yold>1e-6 ? (ynew[j]/yold) : 0;
      r = Math.min(1, Math.max(0, r*s));
      g = Math.min(1, Math.max(0, g*s));
      b = Math.min(1, Math.max(0, b*s));
      dst[i]   = Math.round(255*linearToSrgb(r));
      dst[i+1] = Math.round(255*linearToSrgb(g));
      dst[i+2] = Math.round(255*linearToSrgb(b));
      dst[i+3] = src[i+3];
    }
    return out;
  }

  // Thompson/Chung–Legge parameterization
  const SPN = 199, SPN_l = Math.log10(SPN);
  const FPN = 0.915, FPN_l = Math.log10(FPN);
  const wL = 0.68, wH = 1.28;

  function cFromPR(PR){
    const t = Math.pow(10, -PR);
    return (2 - t) / (199 * t);
  }
  function aFromLogMARandC(logMAR, c){
    const S = Math.pow(10, -logMAR);
    const FCN = 14.0; // normal cutoff cycles/deg (calibration)
    const FCl = Math.log10(Math.max(1e-6, S*FCN));
    const term = Math.max(0, SPN_l + Math.log10(Math.max(1e-9, c)));
    const delta = Math.sqrt(term) / wH;
    const FPl = FCl - delta;
    const FPR = Math.pow(10, FPl);
    return FPR / FPN;
  }
  function Sl_log(f_cpd, a, c){
    const fl = Math.log10(Math.max(1e-6, f_cpd));
    const FPl = FPN_l + Math.log10(Math.max(1e-9, a));
    const w = (f_cpd < Math.pow(10, FPl)) ? wL : wH;
    return SPN_l + Math.log10(Math.max(1e-9, c)) - Math.pow(fl - FPl, 2) * (w*w);
  }
  function bandGain(f_cpd, a, c){
    const dlog = Sl_log(f_cpd, a, c) - Sl_log(f_cpd, 1.0, 1.0);
    const g = Math.pow(10, dlog);
    return Math.min(1, Math.max(0, g));
  }
function baseCSF(f){ const beta=2.2; return f*Math.exp(-beta*f); }
  
function csfGainBand(i,total,logMAR,PR){
  const c = cFromPR(PR);
  const a = aFromLogMARandC(logMAR, c);
  const ppd = pxPerDeg();
  const f = bandCenter_cpd(i, total, ppd);
  return bandGain(f, a, c);
}


  
function applyCSF(logMAR, PR, levels, strength){
  if(!procMat) { setStatus('Load an image first.'); return; }
  // 1) linear luminance from RGBA
  const Ylin = rgbaToLinearY(procMat);

  // 2) Laplacian pyramid on float
  const Y32 = new cv.Mat(); Ylin.convertTo(Y32, cv.CV_32F, 1.0);
  const pyr = pyrBuildLaplacian32(Y32, levels);

  // 3) parameters from clinical controls
  const c = cFromPR(PR);
  const a = aFromLogMARandC(logMAR, c);
  const ppd = pxPerDeg();

  // 4) per-band gains using true cycles/degree
  let gainsInfo=[];
  for(let i=0;i<pyr.lP.length;i++){
    const f = bandCenter_cpd(i, pyr.lP.length+1, ppd);
    const g = (1-strength) + strength*bandGain(f, a, c);
    gainsInfo.push(`${f.toFixed(2)}c/deg→${g.toFixed(2)}`);
    cv.multiply(pyr.lP[i], new cv.Scalar(g), pyr.lP[i]);
  }
  // residual lowpass scaling by c
  const g0 = Math.min(1, Math.max(0, c));
  cv.multiply(pyr.gP[pyr.gP.length-1], new cv.Scalar(g0), pyr.gP[pyr.gP.length-1]);

  // 5) reconstruct, clamp
  const Yrec = pyrReconstruct32(pyr.lP, pyr.gP[pyr.gP.length-1]);
  cv.min(Yrec, new cv.Scalar(1), Yrec); cv.max(Yrec, new cv.Scalar(0), Yrec);

  // 6) put back into RGBA (preserve chroma) and display
  const outRGBA = replaceYKeepChroma(Yrec, procMat);
  procMat.delete(); procMat = outRGBA; cv.imshow('proc', procMat);

  // cleanup
  [Ylin,Y32,Yrec].forEach(m=>m.delete());
  pyr.gP.forEach(m=>m.delete()); pyr.lP.forEach(m=>m.delete());

  const infoEl = document.getElementById('csfInfo');
  if(infoEl){ infoEl.textContent = `Bands: ${gainsInfo.join(' · ')} | ppd≈${ppd.toFixed(1)} | a=${a.toFixed(3)} c=${c.toFixed(3)}`; }
}


  // ---------- Other effects ----------
  function applyBlur(px){ if(!procMat) return; const out=new cv.Mat(); const k=Math.max(1,(Math.floor(px)|1));
    cv.GaussianBlur(procMat,out,new cv.Size(k,k),0,0,cv.BORDER_DEFAULT); procMat.delete(); procMat=out; cv.imshow('proc', procMat); }
  function applyCanny(t1,t2){ if(!procMat) return; const gray=new cv.Mat(); cv.cvtColor(procMat,gray,cv.COLOR_RGBA2GRAY,0);
    const edges=new cv.Mat(); cv.Canny(gray,edges,Number(t1),Number(t2),3,false);
    const disp=new cv.Mat(); cv.cvtColor(edges,disp,cv.COLOR_GRAY2RGBA,0); procMat.delete(); procMat=disp; cv.imshow('proc', procMat); gray.delete(); edges.delete(); }
  function applyYellow(intensity){
    if(!procMat) return;
    const a=Math.max(0,Math.min(1,intensity/100));
    const mv=new cv.MatVector(); cv.split(procMat,mv);
    const R=mv.get(0), G=mv.get(1), B=mv.get(2), A=(mv.size()>=4? mv.get(3): null);
    let Rf=new cv.Mat(); R.convertTo(Rf,cv.CV_32F);
    let Gf=new cv.Mat(); G.convertTo(Gf,cv.CV_32F);
    let Bf=new cv.Mat(); B.convertTo(Bf,cv.CV_32F);
    const up=1+0.6*a, down=1-0.8*a;
    cv.multiply(Rf,new cv.Scalar(up),Rf);
    cv.multiply(Gf,new cv.Scalar(up),Gf);
    cv.multiply(Bf,new cv.Scalar(down),Bf);
    cv.min(Rf,new cv.Scalar(255),Rf); cv.max(Rf,new cv.Scalar(0),Rf);
    cv.min(Gf,new cv.Scalar(255),Gf); cv.max(Gf,new cv.Scalar(0),Gf);
    cv.min(Bf,new cv.Scalar(255),Bf); cv.max(Bf,new cv.Scalar(0),Bf);
    Rf.convertTo(R,cv.CV_8U); Gf.convertTo(G,cv.CV_8U); Bf.convertTo(B,cv.CV_8U);
    const mv2=new cv.MatVector(); mv2.push_back(R); mv2.push_back(G); mv2.push_back(B);
    if(A){ mv2.push_back(A); }
    const merged=new cv.Mat(); cv.merge(mv2, merged);
    procMat.delete(); procMat=merged; cv.imshow('proc', procMat);
    // cleanup
    R.delete(); G.delete(); B.delete(); Rf.delete(); Gf.delete(); Bf.delete(); mv.delete(); mv2.delete(); if(A) A.delete();
  }
  function applyContrast(percent){ if(!procMat) return; const a=Math.max(0,Math.min(1,percent/100));
    const out=new cv.Mat(procMat.rows,procMat.cols,procMat.type()); const mid=new cv.Mat(procMat.rows,procMat.cols,procMat.type(),[128,128,128,255]);
    cv.addWeighted(procMat,1-a,mid,a,0,out); procMat.delete(); procMat=out; cv.imshow('proc', procMat); mid.delete(); }
  function applyScotoma(sizePct,featherPx){ if(!procMat) return; const w=procMat.cols,h=procMat.rows; const r=Math.round(Math.min(w,h)*(sizePct/100)); const cx=Math.round(w/2),cy=Math.round(h/2);
    const mask=cv.Mat.zeros(h,w,cv.CV_8UC1); cv.circle(mask,new cv.Point(cx,cy),r,new cv.Scalar(255),-1);
    if(featherPx>0){ const k=Math.max(1,(featherPx|1)); cv.GaussianBlur(mask,mask,new cv.Size(k,k),0,0,cv.BORDER_DEFAULT); }
    const black=cv.Mat.zeros(h,w,procMat.type()); const inv=new cv.Mat(); cv.bitwise_not(mask,inv);
    const fg=new cv.Mat(),bg=new cv.Mat(),res=new cv.Mat(); cv.bitwise_and(procMat,procMat,fg,inv); cv.bitwise_and(black,black,bg,mask); cv.add(fg,bg,res);
    procMat.delete(); procMat=res; cv.imshow('proc', procMat); mask.delete(); black.delete(); inv.delete(); fg.delete(); bg.delete(); }

  // ---------- Wiring ----------
  window.addEventListener('DOMContentLoaded',()=>{
    origCanvas=document.getElementById('orig'); procCanvas=document.getElementById('proc'); statusEl=document.getElementById('status');

    const fileInput=document.getElementById('fileInput'); const dropArea=document.getElementById('dropArea');
    const maxPixelsRange=document.getElementById('maxPixels'); const maxPixelsLabel=document.getElementById('maxPixelsLabel');
    function updateCap(){ maxPixels=Number(maxPixelsRange.value)*1_000_000; maxPixelsLabel.textContent=`${maxPixelsRange.value} MP`; } updateCap();
    maxPixelsRange.addEventListener('input', updateCap);

    fileInput.addEventListener('change', e=>{ const f=e.target.files[0]; if(f) handleFile(f); });
    ['dragenter','dragover','dragleave','drop'].forEach(evt=>dropArea.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); }, false));
    ['dragenter','dragover'].forEach(evt=>dropArea.addEventListener(evt, ()=>dropArea.classList.add('dragover'), false));
    ['dragleave','drop'].forEach(evt=>dropArea.addEventListener(evt, ()=>dropArea.classList.remove('dragover'), false));
    dropArea.addEventListener('drop', e=>{ const f=e.dataTransfer.files && e.dataTransfer.files[0]; if(f) handleFile(f); });

    const logmar=document.getElementById('logmar'), logmarVal=document.getElementById('logmarVal'), snellen=document.getElementById('snellen');
    const pr=document.getElementById('pr'), prVal=document.getElementById('prVal');
    const levels=document.getElementById('levels'), levelsVal=document.getElementById('levelsVal');
    const strength=document.getElementById('strength'), strengthVal=document.getElementById('strengthVal');
    const applyCSFBtn=document.getElementById('applyCSF');

    function labels(){ const lv=Number(logmar.value); logmarVal.textContent=lv.toFixed(2); snellen.textContent=snellenFromLogMAR(lv);
                       prVal.textContent=Number(pr.value).toFixed(2); levelsVal.textContent=levels.value; strengthVal.textContent=Number(strength.value).toFixed(2); }
    labels(); [logmar,pr,levels,strength].forEach(el=>el.addEventListener('input', labels));

    applyCSFBtn.addEventListener('click', ()=>applyCSF(Number(logmar.value), Number(pr.value), Number(levels.value), Number(strength.value)));

    const blur=document.getElementById('blur'), blurVal=document.getElementById('blurVal'); document.getElementById('applyBlur').addEventListener('click', ()=>applyBlur(Number(blur.value)));
    blur.addEventListener('input', ()=>{ blurVal.textContent=blur.value; });

    const canny1=document.getElementById('canny1'), canny2=document.getElementById('canny2'); document.getElementById('applyCanny').addEventListener('click', ()=>applyCanny(Number(canny1.value), Number(canny2.value)));

    const yellow=document.getElementById('yellow'), yellowVal=document.getElementById('yellowVal'); document.getElementById('applyYellow').addEventListener('click', ()=>applyYellow(Number(yellow.value)));
    yellow.addEventListener('input', ()=>{ yellowVal.textContent=yellow.value+'%'; });

    const contrast=document.getElementById('contrast'), contrastVal=document.getElementById('contrastVal'); document.getElementById('applyContrast').addEventListener('click', ()=>applyContrast(Number(contrast.value)));
    contrast.addEventListener('input', ()=>{ contrastVal.textContent=contrast.value+'%'; });

    const scSize=document.getElementById('scSize'), scSizeVal=document.getElementById('scSizeVal');
    const scFeather=document.getElementById('scFeather'), scFeatherVal=document.getElementById('scFeatherVal');
    document.getElementById('applyScotoma').addEventListener('click', ()=>applyScotoma(Number(scSize.value), Number(scFeather.value)));
    scSize.addEventListener('input', ()=>{ scSizeVal.textContent=scSize.value+'%'; });
    scFeather.addEventListener('input', ()=>{ scFeatherVal.textContent=scFeather.value; });

    document.getElementById('reset').addEventListener('click', resetProcessed);
    document.getElementById('download').addEventListener('click', ()=>{ const link=document.createElement('a'); link.download='processed.png'; link.href=proc.toDataURL('image/png'); link.click(); });
  });
  </script>
</body>
</html>
