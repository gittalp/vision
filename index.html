<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Visual Accessibility Prototype — Working Build</title>
  <style>
    :root { --bg:#f6f7fb; --fg:#111; --muted:#666; --pri:#2b6cb0; --card:#fff; }
    *{box-sizing:border-box} body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg)}
    header{padding:20px 16px} header h1{margin:0 0 6px;font-size:1.25rem}
    main{display:grid;grid-template-columns:1fr 1fr;gap:16px;padding:0 16px 24px}
    @media (max-width:1000px){ main{grid-template-columns:1fr} }
    .panel{background:var(--card);border-radius:14px;padding:14px;box-shadow: 0 1px 6px rgba(0,0,0,.06)}
    .panel h2{margin:0 0 10px;font-size:1.05rem}
    canvas{width:100%;height:auto;background:#222;border-radius:10px;border:1px solid #ddd}
    details{margin-top:10px}
    .tool-row{display:flex;gap:14px;flex-wrap:wrap}
    .tool{flex:1;min-width:240px}
    label{display:block;margin:6px 0;color:#222}
    input[type="range"]{width:100%}
    .button{background:var(--pri);color:#fff;border:none;border-radius:10px;padding:8px 12px;cursor:pointer}
    .button:hover{background:#1e5a96}
    .button.secondary{background:#444}
    .button.secondary:hover{background:#333}
    .uploader{border:2px dashed #bbb;border-radius:12px;padding:16px;text-align:center;background:#fbfbfb}
    .uploader.dragover{background:#eef7ff;border-color:#339}
    #fileInput{display:none}
    #status{margin-top:10px;font-size:0.95rem;color:#333;white-space:pre-wrap}
    small{display:block;color:#555;font-size:0.85rem}
    .debug{background:#f0f8ff;border:1px solid #b6d7ff;padding:8px;margin:8px 0;border-radius:6px;font-family:monospace;font-size:0.8rem}
  </style>
</head>
<body>
  <header>
    <h1>Visual Accessibility Prototype — Working Build</h1>
    <p>Upload a photo to simulate various visual impairments. All processing runs locally in your browser.</p>
  </header>

  <main>
    <section class="panel">
      <h2>Original</h2>
      <div class="uploader" id="dropArea" aria-label="Drop image here">
        <p><strong>Drop image here</strong> or <label for="fileInput" class="button">Choose a file</label></p>
        <input id="fileInput" type="file" accept="image/*"/>
        <small>PNG/JPG recommended • Large images are auto-downscaled for performance</small>
      </div>
      <canvas id="orig"></canvas>
    </section>

    <section class="panel">
      <h2>Processed</h2>
      <canvas id="proc"></canvas>
      <div id="debugInfo" class="debug" style="display:none"></div>
    </section>
  </main>

  <section class="panel" style="margin:0 16px 24px">
    <details open>
      <summary><strong>Acuity & Contrast Sensitivity</strong></summary>
      <div class="tool-row">
        <div class="tool">
          <h3>Visual Acuity</h3>
          <label>logMAR: <span id="logmarVal">0.00</span> <small>Snellen: <span id="snellen">20/20</span></small></label>
          <input id="logmar" type="range" min="0.0" max="1.5" step="0.05" value="0.00"/>
          <small>0.0 = 20/20, 0.3 = 20/40, 0.7 = 20/100, 1.0 = 20/200</small>
        </div>
        <div class="tool">
          <h3>Contrast Sensitivity</h3>
          <label>Peak CS: <span id="peakCSVal">100</span></label>
          <input id="peakCS" type="range" min="1" max="200" step="5" value="100"/>
          <small>Normal ≈ 100-200, Impaired < 50</small>
        </div>
      </div>
      <div class="tool-row">
        <div class="tool">
          <h3>Filter Settings</h3>
          <label>Pyramid Levels: <span id="levelsVal">5</span></label>
          <input id="levels" type="range" min="3" max="7" step="1" value="5"/>
          <label>Effect Strength: <span id="strengthVal">1.00</span></label>
          <input id="strength" type="range" min="0.0" max="1.0" step="0.05" value="1.00"/>
          <label style="display:block;margin-top:8px;">
            <input type="checkbox" id="autoApply" checked/> Auto-apply when sliders change
          </label>
          <label style="display:block;margin-top:4px;">
            <input type="checkbox" id="showDebug"/> Show debug info
          </label>
          <button id="applyCSF" class="button">Apply Vision Filter</button>
        </div>
      </div>
    </details>

    <details>
      <summary><strong>Other Visual Effects</strong></summary>
      <div class="tool-row">
        <div class="tool">
          <h3>Lens Yellowing (Age-Related)</h3>
          <label>Amount: <span id="yellVal">0</span>%</label>
          <input id="yellowing" type="range" min="0" max="100" step="5" value="0"/>
          <button id="applyYellow" class="button secondary">Apply Yellowing</button>
        </div>
        <div class="tool">
          <h3>Global Contrast</h3>
          <label>Adjustment: <span id="contrastVal">0</span>%</label>
          <input id="contrast" type="range" min="-50" max="50" step="5" value="0"/>
          <button id="applyContrast" class="button secondary">Apply Contrast</button>
        </div>
      </div>
      <div class="tool-row">
        <div class="tool">
          <h3>Central Scotoma (Blind Spot)</h3>
          <label>Size: <span id="scSizeVal">20</span>%</label>
          <input id="scSize" type="range" min="5" max="60" step="1" value="20"/>
          <label>Feather: <span id="scFeatherVal">20</span></label>
          <input id="scFeather" type="range" min="0" max="50" step="1" value="20"/>
          <button id="applyScotoma" class="button secondary">Apply Scotoma</button>
        </div>
        <div class="tool">
          <h3>Simple Blur (Demo)</h3>
          <label>Sigma: <span id="blurVal">3</span></label>
          <input id="blur" type="range" min="0" max="15" step="0.5" value="3"/>
          <button id="applyBlur" class="button secondary">Apply Blur</button>
        </div>
      </div>
    </details>

    <div class="tool-row" style="margin-top:10px">
      <button id="reset" class="button">Reset to Original</button>
      <button id="download" class="button">Download PNG</button>
      <span id="status" style="margin-left:8px"></span>
    </div>
  </section>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
  let origMat=null, procMat=null, origCanvas=null, procCanvas=null, statusEl=null;
  let maxPixels=2000000; // Reduced for better performance
  let debugMode = false;
  
  function setStatus(msg){ 
    statusEl && (statusEl.textContent = String(msg||'')); 
    console.log('Status:', msg);
  }
  
  function setDebugInfo(info){
    const debugEl = document.getElementById('debugInfo');
    if(debugEl && debugMode){
      debugEl.style.display = 'block';
      debugEl.textContent = info;
    } else if(debugEl) {
      debugEl.style.display = 'none';
    }
  }
  
  function onCvReady(){ 
    setStatus('OpenCV.js loaded and ready.'); 
  }
  
  // Handle OpenCV initialization
  if (typeof cv !== 'undefined') {
    if (cv.onRuntimeInitialized) {
      onCvReady();
    } else {
      cv['onRuntimeInitialized'] = onCvReady;
    }
  } else {
    // OpenCV not loaded yet, wait for it
    window.addEventListener('load', function(){
      if (typeof cv !== 'undefined') {
        cv['onRuntimeInitialized'] = onCvReady;
      }
    });
  }

  function fitCanvasToImage(canvas, w, h){
    const px = w * h;
    if(px > maxPixels){ 
      const s = Math.sqrt(maxPixels / px); 
      w = Math.round(w * s); 
      h = Math.round(h * s); 
    }
    canvas.width = w; 
    canvas.height = h;
    return {width: w, height: h};
  }
  
  function loadImage(file){
    return new Promise((resolve, reject) => {
      if(!file || !file.type?.startsWith('image/')) {
        return reject(new Error('Please choose an image file.'));
      }
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Could not read image.'));
      img.src = URL.createObjectURL(file);
    });
  }
  
  async function handleFile(file){
    try{
      setStatus('Loading image...');
      const img = await loadImage(file);
      
      const dims = fitCanvasToImage(origCanvas, img.naturalWidth || img.width, img.naturalHeight || img.height);
      const ctx = origCanvas.getContext('2d');
      ctx.clearRect(0, 0, origCanvas.width, origCanvas.height);
      ctx.drawImage(img, 0, 0, origCanvas.width, origCanvas.height);
      
      // Clean up previous matrices
      if(origMat) origMat.delete(); 
      if(procMat) procMat.delete();
      
      // Create OpenCV matrices
      const imageData = ctx.getImageData(0, 0, origCanvas.width, origCanvas.height);
      origMat = cv.matFromImageData(imageData);
      procMat = origMat.clone();
      
      // Display processed image
      cv.imshow('proc', procMat);
      
      setStatus(`Loaded ${file.name} (${img.naturalWidth}×${img.naturalHeight} → ${dims.width}×${dims.height})`);
      
      // Auto-apply if enabled
      if(document.getElementById('autoApply')?.checked){
        applyVisionFilter();
      }
      
    } catch(e){ 
      setStatus('Error: ' + (e.message || 'Failed to load image.')); 
      console.error('Load error:', e);
    }
  }
  
  function resetProcessed(){ 
    if(!origMat) {
      setStatus('No image loaded.');
      return;
    }
    if(procMat) procMat.delete(); 
    procMat = origMat.clone(); 
    cv.imshow('proc', procMat); 
    setStatus('Reset to original.'); 
    setDebugInfo('');
  }

  // ---------- Improved CSF-based Vision Simulation ----------
  
  // Convert sRGB to linear RGB
  function srgbToLinear(u){ 
    return (u <= 0.04045) ? (u / 12.92) : Math.pow((u + 0.055) / 1.055, 2.4); 
  }
  
  function linearToSrgb(u){ 
    return (u <= 0.0031308) ? (12.92 * u) : (1.055 * Math.pow(u, 1/2.4) - 0.055); 
  }

  // Convert RGBA image to luminance (Y channel in linear space)
  function rgbaToLinearLuminance(rgba){
    const Y = new cv.Mat(rgba.rows, rgba.cols, cv.CV_32F);
    const N = rgba.rows * rgba.cols;
    const src = rgba.data;
    const ydata = new Float32Array(Y.data.buffer);
    
    for(let j = 0, i = 0; j < N; j++, i += 4){
      const r = srgbToLinear(src[i] / 255);
      const g = srgbToLinear(src[i+1] / 255);
      const b = srgbToLinear(src[i+2] / 255);
      // ITU-R BT.709 luminance weights
      ydata[j] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }
    return Y;
  }

  // Replace luminance while preserving chromaticity
  function replaceYKeepChroma(newY, originalRGBA){
    const out = new cv.Mat(originalRGBA.rows, originalRGBA.cols, originalRGBA.type());
    const N = originalRGBA.rows * originalRGBA.cols;
    const src = originalRGBA.data;
    const dst = out.data;
    const ynew = new Float32Array(newY.data.buffer);
    
    for(let j = 0, i = 0; j < N; j++, i += 4){
      let r = srgbToLinear(src[i] / 255);
      let g = srgbToLinear(src[i+1] / 255);
      let b = srgbToLinear(src[i+2] / 255);
      
      const yold = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      const scale = yold > 1e-6 ? (ynew[j] / yold) : 0;
      
      r = Math.min(1, Math.max(0, r * scale));
      g = Math.min(1, Math.max(0, g * scale));
      b = Math.min(1, Math.max(0, b * scale));
      
      dst[i]   = Math.round(255 * linearToSrgb(r));
      dst[i+1] = Math.round(255 * linearToSrgb(g));
      dst[i+2] = Math.round(255 * linearToSrgb(b));
      dst[i+3] = src[i+3]; // Alpha unchanged
    }
    return out;
  }

  // Build Laplacian pyramid for frequency decomposition
  function buildLaplacianPyramid(grayMat, levels){
    const gaussianPyramid = [];
    const laplacianPyramid = [];
    
    let current = grayMat.clone();
    
    for(let i = 0; i < levels; i++){
      gaussianPyramid.push(current.clone());
      
      // Downsample
      const down = new cv.Mat();
      cv.pyrDown(current, down);
      
      // Upsample back to current size
      const up = new cv.Mat();
      cv.pyrUp(down, up, current.size());
      
      // Laplacian = original - upsampled
      const laplacian = new cv.Mat();
      cv.subtract(current, up, laplacian);
      laplacianPyramid.push(laplacian);
      
      current.delete();
      current = down;
      up.delete();
    }
    
    // Add the residual (smallest Gaussian level)
    gaussianPyramid.push(current);
    
    return { gaussian: gaussianPyramid, laplacian: laplacianPyramid };
  }

  function reconstructFromLaplacianPyramid(laplacianPyramid, residual){
    let current = residual.clone();
    
    for(let i = laplacianPyramid.length - 1; i >= 0; i--){
      const up = new cv.Mat();
      cv.pyrUp(current, up, laplacianPyramid[i].size());
      
      const reconstructed = new cv.Mat();
      cv.add(up, laplacianPyramid[i], reconstructed);
      
      current.delete();
      current = reconstructed;
      up.delete();
    }
    
    return current;
  }

  // Improved CSF model based on literature
  function contrastSensitivityFunction(spatialFreq_cpd, peakCS = 100, cutoffFreq = 30){
    // Simplified CSF based on Campbell & Robson (1968) and later work
    // Peak sensitivity around 3-4 cycles per degree
    const peakFreq = 3.5; // cycles per degree
    const lowFreqFalloff = 1.2;
    const highFreqFalloff = 0.7;
    
    if(spatialFreq_cpd <= 0) return 0.1;
    
    const ratio = spatialFreq_cpd / peakFreq;
    let sensitivity;
    
    if(ratio < 1){
      // Low frequency roll-off
      sensitivity = peakCS * Math.pow(ratio, lowFreqFalloff);
    } else {
      // High frequency roll-off  
      sensitivity = peakCS * Math.pow(ratio, -highFreqFalloff);
    }
    
    // Apply cutoff for high frequencies
    if(spatialFreq_cpd > cutoffFreq){
      const rolloff = Math.exp(-(spatialFreq_cpd - cutoffFreq) / 5);
      sensitivity *= rolloff;
    }
    
    return Math.max(0.1, sensitivity);
  }

  function applyVisionFilter(){
    if(!procMat || typeof cv === 'undefined'){ 
      setStatus('Load an image first or wait for OpenCV to load.'); 
      return; 
    }
    
    setStatus('Applying vision filter...');
    
    try {
      // Get parameters
      const logMAR = Number(document.getElementById('logmar').value);
      const peakCS = Number(document.getElementById('peakCS').value);
      const levels = Number(document.getElementById('levels').value);
      const strength = Number(document.getElementById('strength').value);
      
      // Convert logMAR to acuity factor
      const acuityFactor = Math.pow(10, -logMAR); // 1.0 = normal, 0.1 = very poor
      const highFreqCutoff = acuityFactor * 30; // Approximate cutoff in cycles/degree
      
      // Convert to linear luminance
      const luminance = rgbaToLinearLuminance(procMat);
      const luminance32 = new cv.Mat();
      luminance.convertTo(luminance32, cv.CV_32F);
      
      // Build frequency pyramid
      const pyramid = buildLaplacianPyramid(luminance32, levels);
      
      let debugInfo = `Levels: ${levels}, logMAR: ${logMAR.toFixed(2)}, Peak CS: ${peakCS}\n`;
      
      // Apply CSF-based filtering to each frequency band
      for(let i = 0; i < pyramid.laplacian.length; i++){
        // Estimate spatial frequency for this pyramid level
        // Each level represents roughly a doubling of spatial frequency
        const baseFreq = 0.5; // cycles per pixel at full resolution
        const levelFreq = baseFreq * Math.pow(2, i);
        // Convert to cycles per degree (rough approximation)
        const freqCpd = levelFreq * 60; // Assuming ~60 pixels per degree
        
        // Calculate contrast sensitivity for this frequency
        const normalCS = contrastSensitivityFunction(freqCpd, 100, 60);
        const impairedCS = contrastSensitivityFunction(freqCpd, peakCS, highFreqCutoff);
        
        // Gain factor (how much to attenuate this frequency band)
        const gain = impairedCS / normalCS;
        const finalGain = (1 - strength) + strength * gain;
        
        debugInfo += `Level ${i}: ${freqCpd.toFixed(1)} cpd, gain: ${finalGain.toFixed(3)}\n`;
        
        // Apply gain to this frequency band
        cv.multiply(pyramid.laplacian[i], new cv.Scalar(finalGain), pyramid.laplacian[i]);
      }
      
      // Reconstruct the image
      const reconstructed = reconstructFromLaplacianPyramid(pyramid.laplacian, pyramid.gaussian[pyramid.gaussian.length - 1]);
      
      // Clamp to valid range [0, 1]
      cv.min(reconstructed, new cv.Scalar(1), reconstructed);
      cv.max(reconstructed, new cv.Scalar(0), reconstructed);
      
      // Convert back to RGBA, preserving color
      const resultRGBA = replaceYKeepChroma(reconstructed, procMat);
      
      // Update display
      procMat.delete();
      procMat = resultRGBA;
      cv.imshow('proc', procMat);
      
      // Clean up
      luminance.delete();
      luminance32.delete();
      reconstructed.delete();
      pyramid.gaussian.forEach(m => m.delete());
      pyramid.laplacian.forEach(m => m.delete());
      
      setStatus(`Vision filter applied (${levels} levels, strength=${strength.toFixed(2)})`);
      setDebugInfo(debugInfo);
      
    } catch(e) {
      setStatus('Error applying filter: ' + e.message);
      console.error('Vision filter error:', e);
    }
  }

  // ---------- Other Effects ----------
  
  function applyBlur(sigma){
    if(!procMat) { setStatus('Load an image first.'); return; }
    
    const ksize = Math.max(1, Math.floor(sigma * 6) | 1); // Ensure odd kernel size
    const blurred = new cv.Mat();
    cv.GaussianBlur(procMat, blurred, new cv.Size(ksize, ksize), sigma, sigma, cv.BORDER_DEFAULT);
    
    procMat.delete();
    procMat = blurred;
    cv.imshow('proc', procMat);
    setStatus(`Applied Gaussian blur (σ=${sigma})`);
  }
  
  function applyYellowing(percent){
    if(!procMat) { setStatus('Load an image first.'); return; }
    
    const factor = Math.max(0, Math.min(1, percent / 100));
    const result = new cv.Mat(procMat.rows, procMat.cols, procMat.type());
    const src = procMat.data;
    const dst = result.data;
    
    for(let i = 0; i < src.length; i += 4){
      const r = src[i];
      const g = src[i + 1]; 
      const b = src[i + 2];
      
      // Yellowing effect: reduce blue, slightly enhance red/green
      const newB = Math.round(b * (1 - 0.8 * factor));
      const newR = Math.min(255, Math.round(r * (1 + 0.1 * factor)));
      const newG = Math.min(255, Math.round(g * (1 + 0.05 * factor)));
      
      dst[i] = newR;
      dst[i + 1] = newG;
      dst[i + 2] = newB;
      dst[i + 3] = src[i + 3]; // Alpha unchanged
    }
    
    procMat.delete();
    procMat = result;
    cv.imshow('proc', procMat);
    setStatus(`Applied lens yellowing (${percent}%)`);
  }
  
  function applyGlobalContrast(percent){
    if(!procMat) { setStatus('Load an image first.'); return; }
    
    const p = Math.max(-50, Math.min(50, percent));
    // Convert percentage to contrast multiplier
    const alpha = 1 + (p / 50); // -50% → 0.5, 0% → 1.0, 50% → 1.5
    const beta = 0; // No brightness offset
    
    const result = new cv.Mat();
    procMat.convertTo(result, -1, alpha, beta);
    
    procMat.delete();
    procMat = result;
    cv.imshow('proc', procMat);
    setStatus(`Applied contrast adjustment (${percent}%)`);
  }
  
  function applyScotoma(sizePct, feather){
    if(!procMat) { setStatus('Load an image first.'); return; }
    
    const w = procMat.cols;
    const h = procMat.rows;
    const cx = Math.round(w / 2);
    const cy = Math.round(h / 2);
    const radius = Math.round(Math.min(w, h) * sizePct / 200);
    
    // Create mask
    const mask = new cv.Mat.zeros(h, w, cv.CV_32F);
    
    for(let y = 0; y < h; y++){
      for(let x = 0; x < w; x++){
        const dx = x - cx;
        const dy = y - cy;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        let maskValue = 0; // Default: no scotoma
        
        if(distance <= radius){
          maskValue = 1; // Full scotoma
        } else if(feather > 0 && distance < radius + feather){
          // Feathered edge
          maskValue = 1 - (distance - radius) / feather;
        }
        
        mask.floatPtr(y, x)[0] = Math.max(0, Math.min(1, maskValue));
      }
    }
    
    // Apply scotoma (darken masked areas)
    const result = procMat.clone();
    const channels = new cv.MatVector();
    cv.split(result, channels);
    
    for(let c = 0; c < 3; c++){ // RGB channels only
      const channel = channels.get(c);
      const channel32 = new cv.Mat();
      channel.convertTo(channel32, cv.CV_32F);
      
      // Apply inverted mask (1 - mask) to darken scotoma areas
      const invMask = new cv.Mat();
      cv.subtract(cv.Mat.ones(h, w, cv.CV_32F), mask, invMask);
      
      const masked = new cv.Mat();
      cv.multiply(channel32, invMask, masked);
      
      masked.convertTo(channel, cv.CV_8U);
      
      channel32.delete();
      invMask.delete();
      masked.delete();
    }
    
    cv.merge(channels, result);
    
    // Clean up
    mask.delete();
    for(let i = 0; i < channels.size(); i++){
      channels.get(i).delete();
    }
    channels.delete();
    
    procMat.delete();
    procMat = result;
    cv.imshow('proc', procMat);
    setStatus(`Applied central scotoma (${sizePct}% size, ${feather} feather)`);
  }

  // ---------- UI Event Handlers ----------
  
  window.addEventListener('DOMContentLoaded', () => {
    // Get canvas elements
    origCanvas = document.getElementById('orig');
    procCanvas = document.getElementById('proc');
    statusEl = document.getElementById('status');
    
    // File input handling
    const fileInput = document.getElementById('fileInput');
    const dropArea = document.getElementById('dropArea');
    
    fileInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if(file) handleFile(file);
    });
    
    // Drag and drop
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
      dropArea.addEventListener(evt, e => {
        e.preventDefault();
        e.stopPropagation();
      }, false);
    });
    
    ['dragenter', 'dragover'].forEach(evt => {
      dropArea.addEventListener(evt, () => dropArea.classList.add('dragover'), false);
    });
    
    ['dragleave', 'drop'].forEach(evt => {
      dropArea.addEventListener(evt, () => dropArea.classList.remove('dragover'), false);
    });
    
    dropArea.addEventListener('drop', e => {
      const file = e.dataTransfer.files?.[0];
      if(file) handleFile(file);
    });

    // Vision filter controls
    const logmar = document.getElementById('logmar');
    const logmarVal = document.getElementById('logmarVal');
    const snellen = document.getElementById('snellen');
    const peakCS = document.getElementById('peakCS');
    const peakCSVal = document.getElementById('peakCSVal');
    const levels = document.getElementById('levels');
    const levelsVal = document.getElementById('levelsVal');
    const strength = document.getElementById('strength');
    const strengthVal = document.getElementById('strengthVal');
    const autoApply = document.getElementById('autoApply');
    const showDebug = document.getElementById('showDebug');
    
    // Update display values and Snellen conversion
    function snellenFromLogMAR(logMAR){
      const snellenDecimal = Math.pow(10, -logMAR);
      const denominator = Math.round(20 / snellenDecimal);
      return `20/${denominator}`;
    }
    
    function updateLabels(){
      const logMARValue = Number(logmar.value);
      logmarVal.textContent = logMARValue.toFixed(2);
      snellen.textContent = snellenFromLogMAR(logMARValue);
      peakCSVal.textContent = peakCS.value;
      levelsVal.textContent = levels.value;
      strengthVal.textContent = Number(strength.value).toFixed(2);
    }
    
    function autoApplyFilter(){
      if(autoApply?.checked && origMat){
        resetProcessed();
        applyVisionFilter();
      }
    }
    
    // Initialize labels
    updateLabels();
    
    // Add event listeners for vision filter controls
    [logmar, peakCS, levels, strength].forEach(el => {
      el.addEventListener('input', () => {
        updateLabels();
        autoApplyFilter();
      });
    });
    
    document.getElementById('applyCSF').addEventListener('click', () => {
      resetProcessed();
      applyVisionFilter();
    });
    
    // Debug mode toggle
    showDebug.addEventListener('change', (e) => {
      debugMode = e.target.checked;
      if(!debugMode){
        setDebugInfo('');
      }
    });

    // Other effect controls
    const blur = document.getElementById('blur');
    const blurVal = document.getElementById('blurVal');
    document.getElementById('applyBlur').addEventListener('click', () => {
      applyBlur(Number(blur.value));
    });
    blur.addEventListener('input', () => {
      blurVal.textContent = blur.value;
    });

    const yellowing = document.getElementById('yellowing');
    const yellVal = document.getElementById('yellVal');
    document.getElementById('applyYellow').addEventListener('click', () => {
      applyYellowing(Number(yellowing.value));
    });
    yellowing.addEventListener('input', () => {
      yellVal.textContent = yellowing.value;
    });

    const contrast = document.getElementById('contrast');
    const contrastVal = document.getElementById('contrastVal');
    document.getElementById('applyContrast').addEventListener('click', () => {
      applyGlobalContrast(Number(contrast.value));
    });
    contrast.addEventListener('input', () => {
      contrastVal.textContent = contrast.value;
    });

    const scSize = document.getElementById('scSize');
    const scSizeVal = document.getElementById('scSizeVal');
    const scFeather = document.getElementById('scFeather');
    const scFeatherVal = document.getElementById('scFeatherVal');
    document.getElementById('applyScotoma').addEventListener('click', () => {
      applyScotoma(Number(scSize.value), Number(scFeather.value));
    });
    scSize.addEventListener('input', () => {
      scSizeVal.textContent = scSize.value;
    });
    scFeather.addEventListener('input', () => {
      scFeatherVal.textContent = scFeather.value;
    });

    // Control buttons
    document.getElementById('reset').addEventListener('click', resetProcessed);
    
    document.getElementById('download').addEventListener('click', () => {
      if(!procCanvas){
        setStatus('No processed image to download.');
        return;
      }
      const link = document.createElement('a');
      link.download = 'processed-vision-simulation.png';
      link.href = procCanvas.toDataURL('image/png');
      link.click();
      setStatus('Image downloaded.');
    });
    
    setStatus('Ready. Upload an image to begin.');
  });
  </script>
</body>
</html>
