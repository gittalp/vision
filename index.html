<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Visual Accessibility Prototype — CSF (Fixed)</title>
  <style>
    :root { --bg:#f6f7fb; --fg:#111; --muted:#666; --pri:#2b6cb0; --card:#fff; }
    *{box-sizing:border-box} body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg)}
    header{padding:20px 16px} header h1{margin:0 0 6px;font-size:1.25rem}
    main{display:grid;grid-template-columns:1fr 1fr;gap:16px;padding:0 16px 24px}
    @media (max-width:1000px){ main{grid-template-columns:1fr} }
    .panel{background:var(--card);border-radius:14px;padding:14px;box-shadow: 0 1px 6px rgba(0,0,0,.06)}
    .panel h2{margin:0 0 10px;font-size:1.05rem}
    canvas{width:100%;height:auto;background:#222;border-radius:10px;border:1px solid #ddd}
    details{margin-top:10px}
    .tool-row{display:flex;gap:14px;flex-wrap:wrap}
    .tool{flex:1;min-width:260px}
    label{display:block;margin:6px 0;color:#222}
    input[type="range"]{width:100%}
    .button{background:var(--pri);color:#fff;border:none;border-radius:10px;padding:8px 12px;cursor:pointer}
    .button:hover{background:#1e5a96}
    .button.secondary{background:#444}
    .button.secondary:hover{background:#333}
    .uploader{border:2px dashed #bbb;border-radius:12px;padding:16px;text-align:center;background:#fbfbfb}
    .uploader.dragover{background:#eef7ff;border-color:#339}
    #fileInput{display:none}
    #status{margin-top:10px;font-size:0.95rem;color:#333;white-space:pre-wrap}
    small{display:block;color:#555;font-size:0.85rem}
    .debug{background:#f0f8ff;border:1px solid #b6d7ff;padding:8px;margin:8px 0;border-radius:6px;font-family:ui-monospace,Consolas,monospace;font-size:0.8rem;white-space:pre-wrap}
    .error{color:#a00;font-weight:600}
  </style>
</head>
<body>
  <header>
    <h1>Visual Accessibility Prototype — CSF (Fixed)</h1>
    <p>Upload a photo or render. All processing runs locally in your browser.</p>
  </header>

  <main>
    <section class="panel">
      <h2>Original</h2>
      <div class="uploader" id="dropArea" aria-label="Drop image here">
        <p><strong>Drop image here</strong> or <label for="fileInput" class="button">Choose a file</label></p>
        <input id="fileInput" type="file" accept="image/*"/>
        <small>PNG/JPG recommended • Large images are auto-downscaled for performance</small>
      </div>
      <canvas id="orig"></canvas>
    </section>

    <section class="panel">
      <h2>Processed</h2>
      <canvas id="proc"></canvas>
      <div id="debugInfo" class="debug" style="display:none"></div>
    </section>
  </main>

  <section class="panel" style="margin:0 16px 24px">
    <details open>
      <summary><strong>Acuity & Contrast Sensitivity</strong></summary>
      <div class="tool-row">
        <div class="tool">
          <h3>Visual Acuity</h3>
          <label>logMAR: <span id="logmarVal">0.00</span> <small>Snellen: <span id="snellen">20/20</span></small></label>
          <input id="logmar" type="range" min="0.0" max="1.2" step="0.05" value="0.00"/>
        </div>
        <div class="tool">
          <h3>Pelli–Robson (PR)</h3>
          <label>PR: <span id="prVal">1.40</span></label>
          <input id="pr" type="range" min="0.0" max="2.0" step="0.05" value="1.40"/>
        </div>
        <div class="tool">
          <h3>Angular Scale</h3>
          <label>Pixels per degree: <span id="ppdVal">40</span></label>
          <input id="ppd" type="range" min="10" max="120" step="1" value="40"/>
          <small>Leave at 40 for typical laptop viewing; it just sets the frequency axis for the model.</small>
        </div>
      </div>
      <div class="tool-row">
        <div class="tool">
          <h3>Filter Settings</h3>
          <label>Pyramid Levels: <span id="levelsVal">4</span></label>
          <input id="levels" type="range" min="3" max="6" step="1" value="4"/>
          <label>Effect Strength: <span id="strengthVal">1.00</span></label>
          <input id="strength" type="range" min="0.0" max="1.0" step="0.05" value="1.00"/>
          <label style="display:block;margin-top:8px;"><input type="checkbox" id="autoApply" checked/> Auto-apply when sliders change</label>
          <label style="display:block;margin-top:4px;"><input type="checkbox" id="showDebug"/> Show debug info</label>
          <button id="applyCSF" class="button">Apply Vision Filter</button>
          <small id="csfInfo"></small>
        </div>
      </div>
    </details>

    <details>
      <summary><strong>Other Visual Effects</strong></summary>
      <div class="tool-row">
        <div class="tool">
          <h3>Lens Yellowing</h3>
          <label>Amount: <span id="yellVal">0</span>%</label>
          <input id="yellowing" type="range" min="0" max="100" step="5" value="0"/>
          <button id="applyYellow" class="button secondary">Apply Yellowing</button>
        </div>
        <div class="tool">
          <h3>Global Contrast</h3>
          <label>Adjustment: <span id="contrastVal">0</span>%</label>
          <input id="contrast" type="range" min="-50" max="50" step="5" value="0"/>
          <button id="applyContrast" class="button secondary">Apply Contrast</button>
        </div>
        <div class="tool">
          <h3>Central Scotoma</h3>
          <label>Size: <span id="scSizeVal">20</span>%</label>
          <input id="scSize" type="range" min="5" max="60" step="1" value="20"/>
          <label>Feather: <span id="scFeatherVal">20</span></label>
          <input id="scFeather" type="range" min="0" max="50" step="1" value="20"/>
          <button id="applyScotoma" class="button secondary">Apply Scotoma</button>
        </div>
        <div class="tool">
          <h3>Gaussian Blur (demo)</h3>
          <label>σ: <span id="blurVal">3</span></label>
          <input id="blur" type="range" min="0" max="15" step="0.5" value="3"/>
          <button id="applyBlur" class="button secondary">Apply Blur</button>
        </div>
      </div>
    </details>

    <div class="tool-row" style="margin-top:10px">
      <button id="reset" class="button">Reset to Original</button>
      <button id="download" class="button">Download PNG</button>
      <span id="status" style="margin-left:8px"></span>
    </div>
  </section>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
  let origMat=null, procMat=null, origCanvas=null, procCanvas=null, statusEl=null;
  let maxPixels=3000000;
  let debugMode=false;

  function setStatus(msg){ statusEl && (statusEl.textContent = String(msg||'')); }
  function setDebugInfo(info){
    const el=document.getElementById('debugInfo');
    if(!el) return;
    if(debugMode){ el.style.display='block'; el.textContent=info; }
    else { el.style.display='none'; el.textContent=''; }
  }
  function onCvReady(){ setStatus('OpenCV.js loaded.'); }
  if (typeof cv !== 'undefined') {
    if (cv.onRuntimeInitialized) onCvReady();
    else cv['onRuntimeInitialized']=onCvReady;
  } else {
    window.addEventListener('load', ()=>{ if(typeof cv!=='undefined') cv['onRuntimeInitialized']=onCvReady; });
  }

  function fitCanvasToImage(canvas,w,h){
    const px=w*h;
    if(px>maxPixels){ const s=Math.sqrt(maxPixels/px); w=Math.round(w*s); h=Math.round(h*s); }
    canvas.width=w; canvas.height=h; return {width:w,height:h};
  }
  function loadImage(file){
    return new Promise((resolve,reject)=>{
      if(!file || !file.type || !file.type.startsWith('image/')) return reject(new Error('Please choose an image file.'));
      const img=new Image(); img.onload=()=>resolve(img); img.onerror=()=>reject(new Error('Could not read image.'));
      img.src=URL.createObjectURL(file);
    });
  }
  async function handleFile(file){
    try{
      setStatus('Loading image...');
      const img=await loadImage(file);
      const dims=fitCanvasToImage(origCanvas, img.naturalWidth||img.width, img.naturalHeight||img.height);
      const ctx=origCanvas.getContext('2d');
      ctx.clearRect(0,0,origCanvas.width,origCanvas.height);
      ctx.drawImage(img,0,0,origCanvas.width,origCanvas.height);
      if(origMat) origMat.delete(); if(procMat) procMat.delete();
      const imageData=ctx.getImageData(0,0,origCanvas.width,origCanvas.height);
      origMat=cv.matFromImageData(imageData); procMat=origMat.clone();
      cv.imshow('proc', procMat);
      setStatus(`Loaded ${file.name} (${img.naturalWidth}×${img.naturalHeight} → ${dims.width}×${dims.height})`);
      if(document.getElementById('autoApply')?.checked){ resetProcessed(); applyCSF(); }
    }catch(e){ setStatus('Error: '+(e.message||'Failed to load image.')); }
  }
  function resetProcessed(){ if(!origMat){ setStatus('No image loaded.'); return; } if(procMat) procMat.delete(); procMat=origMat.clone(); cv.imshow('proc', procMat); setStatus('Reset to original.'); setDebugInfo(''); }

  // ----- Linear luminance helpers (SAFE: use .data32F) -----
  function srgbToLinear(u){ return (u<=0.04045)?(u/12.92):Math.pow((u+0.055)/1.055,2.4); }
  function linearToSrgb(u){ return (u<=0.0031308)?(12.92*u):(1.055*Math.pow(u,1/2.4)-0.055); }

  function rgbaToLinearY(rgba){
    const Y=new cv.Mat(rgba.rows, rgba.cols, cv.CV_32F);
    const N=rgba.rows*rgba.cols;
    const src=rgba.data; const ydata=Y.data32F; // SAFE pointer
    let i=0; // src index
    for(let j=0;j<N;j++,i+=4){
      const r=srgbToLinear(src[i]/255), g=srgbToLinear(src[i+1]/255), b=srgbToLinear(src[i+2]/255);
      ydata[j]=0.2126*r + 0.7152*g + 0.0722*b;
    }
    return Y;
  }
  function replaceYKeepChroma(Ylin, rgbaIn){
    const out=new cv.Mat(rgbaIn.rows, rgbaIn.cols, rgbaIn.type());
    const N=rgbaIn.rows*rgbaIn.cols;
    const src=rgbaIn.data; const dst=out.data; const ynew=Ylin.data32F; // SAFE pointer
    let i=0;
    for(let j=0;j<N;j++,i+=4){
      let r=srgbToLinear(src[i]/255), g=srgbToLinear(src[i+1]/255), b=srgbToLinear(src[i+2]/255);
      const yold=0.2126*r + 0.7152*g + 0.0722*b;
      const s = yold>1e-6 ? (ynew[j]/yold) : 0;
      r=Math.min(1,Math.max(0,r*s)); g=Math.min(1,Math.max(0,g*s)); b=Math.min(1,Math.max(0,b*s));
      dst[i]=Math.round(255*linearToSrgb(r));
      dst[i+1]=Math.round(255*linearToSrgb(g));
      dst[i+2]=Math.round(255*linearToSrgb(b));
      dst[i+3]=src[i+3];
    }
    return out;
  }

  // ----- Pyramid -----
  function buildLaplacianPyramid(gray32, levels){
    const gP=[], lP=[]; let cur=gray32.clone();
    for(let i=0;i<levels;i++){
      const down=new cv.Mat(); cv.pyrDown(cur,down);
      const up=new cv.Mat(); cv.pyrUp(down,up,cur.size());
      const lap=new cv.Mat(); cv.subtract(cur,up,lap);
      gP.push(cur); lP.push(lap); cur=down; up.delete();
    }
    gP.push(cur); return {gP,lP};
  }
  function reconstructFromLaplacian(lP, low){
    let cur=low.clone();
    for(let i=lP.length-1;i>=0;i--){
      const up=new cv.Mat(); cv.pyrUp(cur,up,lP[i].size());
      const sum=new cv.Mat(); cv.add(up,lP[i],sum);
      cur.delete(); cur=sum; up.delete();
    }
    return cur;
  }

  // ----- Thompson/Chung–Legge CSF mapping -----
  const SPN=199, SPN_l=Math.log10(SPN);
  const FPN=0.915, FPN_l=Math.log10(FPN);
  const wL=0.68, wH=1.28;
  function cFromPR(PR){ const t=Math.pow(10,-PR); return (2 - t) / (199 * t); }
  function aFromLogMARandC(logMAR, c){
    const S=Math.pow(10,-logMAR);
    const FCN=14.0;
    const FCl=Math.log10(Math.max(1e-6, S*FCN));
    const term=Math.max(0, SPN_l + Math.log10(Math.max(1e-9,c)));
    const delta=Math.sqrt(term)/wH;
    const FPl=FCl - delta;
    const FPR=Math.pow(10,FPl);
    return FPR / FPN;
  }
  function Sl_log(f_cpd, a, c){
    const fl=Math.log10(Math.max(1e-6,f_cpd));
    const FPl=FPN_l + Math.log10(Math.max(1e-9,a));
    const w=(f_cpd < Math.pow(10,FPl)) ? wL : wH;
    return SPN_l + Math.log10(Math.max(1e-9,c)) - Math.pow(fl - FPl, 2) * (w*w);
  }
  function bandGain(f_cpd, a, c){
    const dlog = Sl_log(f_cpd, a, c) - Sl_log(f_cpd, 1.0, 1.0);
    const g = Math.pow(10, dlog);
    return Math.max(0, g);
  }

  // ----- Apply CSF -----
  function bandCenterCPD(levelIndex, totalLevels, ppd){
    const cycPerPx = 0.5 / Math.pow(2, levelIndex + 0.5);
    return cycPerPx * ppd;
  }
  function applyCSF(){
    try{
      if(!procMat){ setStatus('Load an image first.'); return; }
      setStatus('Applying CSF...');
      const logMAR=Number(document.getElementById('logmar').value);
      const PR=Number(document.getElementById('pr').value);
      const levels=Number(document.getElementById('levels').value);
      const strength=Math.min(1, Math.max(0, Number(document.getElementById('strength').value)));
      const ppd=Number(document.getElementById('ppd').value);

      const Ylin=rgbaToLinearY(procMat);
      const Y32=new cv.Mat(); Ylin.convertTo(Y32, cv.CV_32F, 1.0);
      const pyr=buildLaplacianPyramid(Y32, levels);

      const c=cFromPR(PR);
      const a=aFromLogMARandC(logMAR, c);

      let debug=`ppd=${ppd}  a=${a.toFixed(3)}  c=${c.toFixed(3)}\n`;
      const totalBands=pyr.lP.length+1;
      for(let i=0;i<pyr.lP.length;i++){
        const f=bandCenterCPD(i, totalBands, ppd);
        const gain=(1-strength) + strength*bandGain(f, a, c);
        debug+=`L${i}  f≈${f.toFixed(2)} cpd  gain=${gain.toFixed(3)}\n`;
        cv.multiply(pyr.lP[i], new cv.Scalar(gain), pyr.lP[i]);
      }
      const Yrec=reconstructFromLaplacian(pyr.lP, pyr.gP[pyr.gP.length-1]);
      cv.min(Yrec, new cv.Scalar(1), Yrec); cv.max(Yrec, new cv.Scalar(0), Yrec);

      const outRGBA=replaceYKeepChroma(Yrec, procMat);
      procMat.delete(); procMat=outRGBA; cv.imshow('proc', procMat);

      [Ylin,Y32,Yrec].forEach(m=>m.delete()); pyr.gP.forEach(m=>m.delete()); pyr.lP.forEach(m=>m.delete());
      document.getElementById('csfInfo').textContent = debug.split('\n')[0];
      setDebugInfo(debug);
      setStatus('CSF applied.');
    }catch(err){
      setStatus('Error applying CSF: ' + err.message);
      console.error(err);
    }
  }

  // ----- Other effects (scotoma simplified; no pointer math) -----
  function applyBlur(sigma){
    if(!procMat){ setStatus('Load an image first.'); return; }
    const k=Math.max(1, (Math.floor(sigma*6)|1));
    const out=new cv.Mat(); cv.GaussianBlur(procMat,out,new cv.Size(k,k), sigma, sigma, cv.BORDER_DEFAULT);
    procMat.delete(); procMat=out; cv.imshow('proc', procMat);
    setStatus(`Gaussian blur σ=${sigma}`);
  }
  function applyYellowing(percent){
    if(!procMat){ setStatus('Load an image first.'); return; }
    const f=Math.max(0, Math.min(1, percent/100));
    const out=new cv.Mat(procMat.rows, procMat.cols, procMat.type());
    const src=procMat.data, dst=out.data;
    for(let i=0;i<src.length;i+=4){
      const r=src[i], g=src[i+1], b=src[i+2];
      const b2=Math.round(b*(1-0.8*f));
      const r2=Math.min(255, Math.round(r*(1+0.10*f)));
      const g2=Math.min(255, Math.round(g*(1+0.05*f)));
      dst[i]=r2; dst[i+1]=g2; dst[i+2]=b2; dst[i+3]=src[i+3];
    }
    procMat.delete(); procMat=out; cv.imshow('proc', procMat);
    setStatus(`Yellowing ${percent}%`);
  }
  function applyScotoma(sizePct, feather){
    if(!procMat){ setStatus('Load an image first.'); return; }
    const w=procMat.cols, h=procMat.rows;
    // Create 8U single-channel mask
    const mask=new cv.Mat.zeros(h, w, cv.CV_8U);
    const center=new cv.Point(Math.round(w/2), Math.round(h/2));
    const radius=Math.round(Math.min(w,h)*sizePct/200);
    cv.circle(mask, center, radius, new cv.Scalar(255), -1);
    if(feather>0){
      const k=Math.max(1, (Math.floor(feather*2)|1));
      cv.GaussianBlur(mask, mask, new cv.Size(k,k), feather, feather, cv.BORDER_DEFAULT);
    }
    // Invert to keep area outside scotoma
    const inv=new cv.Mat(); cv.bitwise_not(mask, inv);
    const ch=new cv.MatVector(); cv.split(procMat, ch);
    for(let i=0;i<3;i++){
      const tmp=new cv.Mat(); cv.bitwise_and(ch.get(i), inv, tmp); tmp.copyTo(ch.get(i)); tmp.delete();
    }
    const out=new cv.Mat(); cv.merge(ch, out);
    procMat.delete(); procMat=out; cv.imshow('proc', procMat);
    mask.delete(); inv.delete(); for(let i=0;i<ch.size();i++) ch.get(i).delete(); ch.delete();
    setStatus(`Scotoma size=${sizePct}% feather=${feather}`);
  }
  function applyGlobalContrast(percent){
    if(!procMat){ setStatus('Load an image first.'); return; }
    const p=Math.max(-50,Math.min(50,percent));
    const alpha=1+(p/50); const beta=0;
    const out=new cv.Mat(); procMat.convertTo(out, -1, alpha, beta);
    procMat.delete(); procMat=out; cv.imshow('proc', procMat);
    setStatus(`Contrast ${percent}%`);
  }

  // ----- UI wiring -----
  window.addEventListener('DOMContentLoaded', ()=>{
    origCanvas=document.getElementById('orig'); procCanvas=document.getElementById('proc'); statusEl=document.getElementById('status');
    const fileInput=document.getElementById('fileInput'); const dropArea=document.getElementById('dropArea');
    fileInput.addEventListener('change', e=>{ const f=e.target.files[0]; if(f) handleFile(f); });
    ['dragenter','dragover','dragleave','drop'].forEach(evt=>dropArea.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); }, false));
    ['dragenter','dragover'].forEach(evt=>dropArea.addEventListener(evt, ()=>dropArea.classList.add('dragover'), false));
    ['dragleave','drop'].forEach(evt=>dropArea.addEventListener(evt, ()=>dropArea.classList.remove('dragover'), false));
    dropArea.addEventListener('drop', e=>{ const f=e.dataTransfer.files && e.dataTransfer.files[0]; if(f) handleFile(f); });

    const logmar=document.getElementById('logmar'), logmarVal=document.getElementById('logmarVal'), snellen=document.getElementById('snellen');
    const pr=document.getElementById('pr'), prVal=document.getElementById('prVal');
    const ppd=document.getElementById('ppd'), ppdVal=document.getElementById('ppdVal');
    const levels=document.getElementById('levels'), levelsVal=document.getElementById('levelsVal');
    const strength=document.getElementById('strength'), strengthVal=document.getElementById('strengthVal');
    const autoApply=document.getElementById('autoApply'); const showDebug=document.getElementById('showDebug');

    function snellenFromLogMAR(lv){ const s=Math.pow(10,-lv); const den=Math.round(20/s); return `20/${den}`; }
    function labels(){
      const lv=Number(logmar.value); logmarVal.textContent=lv.toFixed(2); snellen.textContent=snellenFromLogMAR(lv);
      prVal.textContent=Number(pr.value).toFixed(2);
      ppdVal.textContent=ppd.value;
      levelsVal.textContent=levels.value; strengthVal.textContent=Number(strength.value).toFixed(2);
    }
    function applyIfAuto(){ if(autoApply && autoApply.checked && origMat){ resetProcessed(); applyCSF(); } }
    labels();
    [logmar,pr,ppd,levels,strength].forEach(el=>el.addEventListener('input', ()=>{ labels(); applyIfAuto(); }));
    document.getElementById('applyCSF').addEventListener('click', ()=>{ resetProcessed(); applyCSF(); });
    document.getElementById('reset').addEventListener('click', resetProcessed);
    document.getElementById('download').addEventListener('click', ()=>{
      const link=document.createElement('a'); link.download='processed.png'; link.href=procCanvas.toDataURL('image/png'); link.click();
    });
    document.getElementById('applyBlur').addEventListener('click', ()=>applyBlur(Number(document.getElementById('blur').value)));
    document.getElementById('applyYellow').addEventListener('click', ()=>applyYellowing(Number(document.getElementById('yellowing').value)));
    document.getElementById('applyContrast').addEventListener('click', ()=>applyGlobalContrast(Number(document.getElementById('contrast').value)));
    document.getElementById('applyScotoma').addEventListener('click', ()=>applyScotoma(Number(document.getElementById('scSize').value), Number(document.getElementById('scFeather').value)));
    document.getElementById('showDebug').addEventListener('change', (e)=>{ debugMode=e.target.checked; if(!debugMode) setDebugInfo(''); });

    setStatus('Ready. Upload an image to begin.');
  });
  </script>
</body>
</html>
