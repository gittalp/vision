<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vision Condition Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/exif-js@2.3.0/exif.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .image-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }
        
        .panel-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            transform: scale(1.02);
        }
        
        .upload-area.dragover {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            border-color: #764ba2;
        }
        
        .upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }
        
        canvas {
            width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            background: #f0f0f0;
            display: block;
        }
        
        .controls {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin: 0 30px 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }
        
        .control-section {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #667eea;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #667eea 0%, #764ba2 100%);
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid #667eea;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid #667eea;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .value-display {
            min-width: 80px;
            padding: 5px 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 20px;
            text-align: center;
            font-weight: 600;
        }
        
        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .info-box {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .info-box p {
            margin: 5px 0;
            color: #555;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: 600;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        input[type="file"] {
            display: none;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üëÅÔ∏è Vision Condition Simulator for Interior Spaces</h1>
            <p class="subtitle">Evaluate how vision conditions affect perception of architectural designs</p>
        </header>
        
        <div class="main-content">
            <div class="image-panel">
                <h2 class="panel-title">Original Image</h2>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üì∑</div>
                    <p><strong>Drop an image here</strong></p>
                    <p>or click to browse</p>
                    <p style="font-size: 0.9em; margin-top: 10px; opacity: 0.8;">Supports: Phone photos, Revit/Enscape renders, or any interior image</p>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                <canvas id="originalCanvas"></canvas>
            </div>
            
            <div class="image-panel">
                <h2 class="panel-title">Simulated Vision</h2>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Processing image...</p>
                </div>
                <canvas id="simulatedCanvas"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-section">
                <h3 class="section-title">Camera Detection & Field of View</h3>
                
                <div class="control-group">
                    <label>Camera Type: <span id="cameraType" style="font-weight: bold;">Not detected</span></label>
                </div>
                
                <div class="control-group">
                    <label>Detected FOV: <span id="detectedFOV" style="font-weight: bold;">--</span></label>
                </div>
                
                <div class="control-group">
                    <label for="fovOverride">Manual FOV Override (degrees):</label>
                    <div class="slider-container">
                        <input type="range" id="fovOverride" min="10" max="180" step="5" value="60">
                        <input type="number" id="fovInput" min="10" max="180" value="60" style="width: 70px; padding: 5px; margin-left: 10px;">
                    </div>
                    <small style="color: #666;">For renders or if camera not detected. Typical: Phone main ~80¬∞, Ultra-wide ~120¬∞, Interior render ~60-90¬∞</small>
                </div>
            </div>
            
            <div class="control-section">
                <h3 class="section-title">Vision Condition</h3>
                <div class="control-group">
                    <label for="condition">Select Condition:</label>
                    <select id="condition">
                        <option value="acuity">Visual Acuity Loss</option>
                        <option value="cataracts">Cataracts</option>
                        <option value="diabetic">Diabetic Retinopathy</option>
                        <option value="macular">Macular Degeneration</option>
                        <option value="glaucoma">Glaucoma</option>
                        <option value="custom">Custom Parameters</option>
                    </select>
                </div>
            </div>
            
            <div class="control-section">
                <h3 class="section-title">Visual Parameters</h3>
                
                <div class="control-group">
                    <label for="acuity">Visual Acuity (Snellen):</label>
                    <div class="slider-container">
                        <input type="range" id="acuity" min="0" max="2.0" step="0.05" value="0">
                        <div class="value-display" id="acuityValue">20/20</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="contrast">Contrast Sensitivity (Pelli-Robson):</label>
                    <div class="slider-container">
                        <input type="range" id="contrast" min="0" max="2.0" step="0.05" value="2.0">
                        <div class="value-display" id="contrastValue">2.00</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="saturation">Color Saturation:</label>
                    <div class="slider-container">
                        <input type="range" id="saturation" min="0" max="100" step="5" value="100">
                        <div class="value-display" id="saturationValue">100%</div>
                    </div>
                </div>

                <div class="control-group">
                    <label for="fieldLoss">Field of View Loss:</label>
                    <div class="slider-container">
                        <input type="range" id="fieldLoss" min="0" max="100" step="5" value="0">
                        <div class="value-display" id="fieldLossValue">0%</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3 class="section-title">Condition-Specific Effects</h3>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="yellowing">
                    <label for="yellowing">Lens Yellowing (Cataracts)</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="floaters">
                    <label for="floaters">Floaters/Hemorrhages (Diabetic)</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="centralScotoma">
                    <label for="centralScotoma">Central Scotoma (Macular)</label>
                </div>
            </div>
            
            <div class="info-box">
                <p><strong>logMAR:</strong> <span id="logmarInfo">0.00</span></p>
                <p><strong>Cycles per Degree:</strong> <span id="cpdInfo">30.00</span></p>
                <p><strong>Blur Sigma:</strong> <span id="sigmaInfo">0.00</span> pixels</p>
            </div>
            
            <div class="info-box" style="margin-top: 15px; background: linear-gradient(135deg, #f093fb20 0%, #f5576c20 100%); border-left-color: #f5576c;">
                <p><strong>Design Considerations:</strong></p>
                <p>‚Ä¢ Check visibility of: stairs, edges, doorways, signage</p>
                <p>‚Ä¢ Ensure adequate contrast between surfaces</p>
                <p>‚Ä¢ Verify lighting levels for navigation</p>
                <p>‚Ä¢ Note: 20/70 or worse = legal blindness in many regions</p>
            </div>
            
            <div class="button-group">
                <button onclick="applySimulation()">Apply Simulation</button>
                <button class="secondary" onclick="resetImage()">Reset</button>
                <button class="secondary" onclick="downloadImage()">Download Result</button>
            </div>
        </div>
    </div>

    <script>
        let originalImage = null;
        let originalCanvas = null;
        let simulatedCanvas = null;
        let originalCtx = null;
        let simulatedCtx = null;
        let detectedFieldOfView = 60; // Default FOV

        // Camera sensor database (2018+ flagship phones)
        const PHONE_SENSORS = {
            // Apple iPhones (sensor width in mm)
            'Apple': {
                // iPhone 16 series
                'iPhone16,2': { main: 9.8, ultrawide: 5.7, tele: 4.2 }, // 16 Pro
                'iPhone16,1': { main: 9.8, ultrawide: 5.7, tele: 4.2 }, // 16 Pro Max
                // iPhone 15 series
                'iPhone15,3': { main: 9.8, ultrawide: 5.7, tele: 4.2 }, // 15 Pro
                'iPhone15,4': { main: 9.8, ultrawide: 5.7, tele: 4.2 }, // 15 Pro Max
                // iPhone 14 series
                'iPhone14,6': { main: 9.8, ultrawide: 5.7, tele: 3.5 }, // 14 Pro
                'iPhone14,7': { main: 9.8, ultrawide: 5.7, tele: 3.5 }, // 14 Pro Max
                // iPhone 13 series
                'iPhone13,3': { main: 7.5, ultrawide: 5.7, tele: 3.5 }, // 13 Pro
                'iPhone13,4': { main: 7.5, ultrawide: 5.7, tele: 3.5 }, // 13 Pro Max
                // Add more models as needed
            },
            'samsung': {
                // Galaxy S24 series
                'SM-S928': { main: 9.6, ultrawide: 5.7, tele: 5.8 }, // S24 Ultra
                'SM-S926': { main: 7.5, ultrawide: 5.7, tele: 3.5 }, // S24+
                // Galaxy S23 series
                'SM-S918': { main: 9.6, ultrawide: 5.7, tele: 3.5 }, // S23 Ultra
                'SM-S916': { main: 7.5, ultrawide: 5.7, tele: 3.5 }, // S23+
                // Galaxy S22 series
                'SM-S908': { main: 9.6, ultrawide: 5.7, tele: 3.5 }, // S22 Ultra
                // Galaxy S21 series
                'SM-G998': { main: 9.6, ultrawide: 5.7, tele: 3.5 }, // S21 Ultra
            },
            'Google': {
                // Pixel 9 series
                'Pixel 9 Pro': { main: 9.8, ultrawide: 5.7, tele: 5.7 },
                'Pixel 9 Pro XL': { main: 9.8, ultrawide: 5.7, tele: 5.7 },
                // Pixel 8 series
                'Pixel 8 Pro': { main: 9.8, ultrawide: 5.7, tele: 5.7 },
                'Pixel 8': { main: 9.8, ultrawide: 5.7 },
                // Pixel 7 series
                'Pixel 7 Pro': { main: 9.8, ultrawide: 5.7, tele: 5.7 },
                'Pixel 6 Pro': { main: 9.8, ultrawide: 5.0, tele: 5.0 },
            }
        };

        // DSLR/Mirrorless sensor sizes (width in mm) - EXPANDED DATABASE
        const CAMERA_SENSORS = {
            // Canon Full Frame
            'Canon EOS R5': 36, 'Canon EOS R6': 36, 'Canon EOS R3': 36,
            'Canon EOS 5D Mark IV': 36, 'Canon EOS 5D Mark III': 36,
            'Canon EOS 6D Mark II': 36, 'Canon EOS 6D': 36,
            'Canon EOS-1D X Mark III': 36, 'Canon EOS-1D X Mark II': 36,
            // Canon APS-C
            'Canon EOS R7': 22.2, 'Canon EOS R10': 22.2,
            'Canon EOS 90D': 22.2, 'Canon EOS 80D': 22.2, 'Canon EOS 70D': 22.2,
            'Canon EOS 7D Mark II': 22.2, 'Canon EOS 7D': 22.2,
            'Canon EOS Rebel': 22.2, // Catches all Rebel models
            'Canon EOS 850D': 22.2, 'Canon EOS 800D': 22.2,
            // Nikon Full Frame
            'NIKON Z 9': 36, 'NIKON Z 8': 36, 'NIKON Z 7': 36, 'NIKON Z 6': 36,
            'NIKON Z 5': 36, 'NIKON Z 7II': 36, 'NIKON Z 6II': 36,
            'NIKON D850': 36, 'NIKON D780': 36, 'NIKON D750': 36,
            'NIKON D810': 36, 'NIKON D800': 36, 'NIKON D610': 36,
            'NIKON Df': 36, 'NIKON D6': 36, 'NIKON D5': 36,
            // Nikon APS-C (DX)
            'NIKON Z 50': 23.6, 'NIKON Z 30': 23.6, 'NIKON Z fc': 23.6,
            'NIKON D7500': 23.6, 'NIKON D7200': 23.6, 'NIKON D7100': 23.6,
            'NIKON D5600': 23.6, 'NIKON D5500': 23.6, 'NIKON D5300': 23.6,
            'NIKON D3500': 23.6, 'NIKON D3400': 23.6, 'NIKON D3300': 23.6,
            'NIKON D500': 23.6,
            // Sony Full Frame
            'SONY A7R V': 36, 'SONY A7R IV': 36, 'SONY A7R III': 36,
            'SONY A7 IV': 36, 'SONY A7 III': 36, 'SONY A7C': 36,
            'SONY A7S III': 36, 'SONY A9 II': 36, 'SONY A9': 36,
            'SONY A1': 36, 'SONY ILCE-7': 36, // Generic A7
            // Sony APS-C
            'SONY A6700': 23.6, 'SONY A6600': 23.6, 'SONY A6500': 23.6,
            'SONY A6400': 23.6, 'SONY A6300': 23.6, 'SONY A6100': 23.6,
            'SONY A6000': 23.6, 'SONY ILCE-6': 23.6, // Generic A6xxx
            // Fujifilm APS-C
            'FUJIFILM X-T5': 23.6, 'FUJIFILM X-T4': 23.6, 'FUJIFILM X-T3': 23.6,
            'FUJIFILM X-T30': 23.6, 'FUJIFILM X-S20': 23.6, 'FUJIFILM X-S10': 23.6,
            'FUJIFILM X-H2': 23.6, 'FUJIFILM X-H2S': 23.6, 'FUJIFILM X-H1': 23.6,
            'FUJIFILM X-Pro3': 23.6, 'FUJIFILM X-Pro2': 23.6,
            'FUJIFILM X100V': 23.6, 'FUJIFILM X100F': 23.6,
            // Fujifilm Medium Format
            'FUJIFILM GFX100': 43.8, 'FUJIFILM GFX100S': 43.8, 'FUJIFILM GFX50S': 43.8,
            // Micro 4/3
            'OLYMPUS OM-1': 17.3, 'OLYMPUS E-M1': 17.3, 'OLYMPUS E-M5': 17.3,
            'Panasonic GH6': 17.3, 'Panasonic GH5': 17.3, 'Panasonic G9': 17.3,
            'Panasonic S5': 36, 'Panasonic S1': 36, // Full frame Panasonic
            // Pentax
            'PENTAX K-1': 36, 'PENTAX K-1 Mark II': 36,
            'PENTAX K-3': 23.6, 'PENTAX K-70': 23.6,
        };

        // Function to detect camera type and calculate FOV
        function detectCameraAndFOV(exifData) {
            const make = (exifData.Make || '').trim();
            const model = (exifData.Model || '').trim();
            const focalLength = exifData.FocalLength;
            const focalLength35mm = exifData.FocalLengthIn35mmFilm;
            
            console.log('Detection attempt - Make:', make, 'Model:', model, 'FL:', focalLength);
            
            let cameraInfo = 'Unknown';
            let fov = null;
            let sensorWidth = null;
            
            // Check if it's a traditional camera - now with better matching
            if (make.match(/Canon|CANON|Nikon|NIKON|Sony|SONY|Fuji|FUJIFILM|Pentax|PENTAX|Olympus|OLYMPUS|Panasonic/i)) {
                // First try exact match with model
                for (let cam in CAMERA_SENSORS) {
                    if (model.toUpperCase().includes(cam.toUpperCase())) {
                        sensorWidth = CAMERA_SENSORS[cam];
                        cameraInfo = `${make} ${model} (${sensorWidth}mm sensor)`;
                        console.log('Found exact match:', cam, 'Sensor:', sensorWidth);
                        break;
                    }
                }
                
                // If not found, try partial matches
                if (!sensorWidth) {
                    // Try to find by make first
                    const makeUpper = make.toUpperCase();
                    const modelUpper = model.toUpperCase();
                    
                    // Check for common patterns
                    if (makeUpper.includes('CANON')) {
                        if (modelUpper.match(/\b(R5|R6|R3|5D|6D|1D[XS]?)\b/) || modelUpper.includes('MARK')) {
                            sensorWidth = 36; // Full frame
                            cameraInfo = `${make} ${model} (Full Frame)`;
                        } else if (modelUpper.match(/\b(R7|R10|[789]0D|[78]00D|[78]50D|7D|REBEL|KISS)\b/)) {
                            sensorWidth = 22.2; // APS-C Canon
                            cameraInfo = `${make} ${model} (APS-C)`;
                        }
                    } else if (makeUpper.includes('NIKON')) {
                        if (modelUpper.match(/\b(Z[5-9]|D[86]|D[78][0-9]0|DF)\b/)) {
                            sensorWidth = 36; // Full frame
                            cameraInfo = `${make} ${model} (Full Frame)`;
                        } else if (modelUpper.match(/\b(Z[35]0|Z ?FC|D[357][0-9]00|D500)\b/)) {
                            sensorWidth = 23.6; // APS-C Nikon
                            cameraInfo = `${make} ${model} (APS-C DX)`;
                        }
                    } else if (makeUpper.includes('SONY')) {
                        if (modelUpper.match(/\b(A7|A9|A1|ILCE-7)\b/)) {
                            sensorWidth = 36; // Full frame
                            cameraInfo = `${make} ${model} (Full Frame)`;
                        } else if (modelUpper.match(/\b(A6[0-9]|ILCE-6[0-9])\b/)) {
                            sensorWidth = 23.6; // APS-C Sony
                            cameraInfo = `${make} ${model} (APS-C)`;
                        }
                    } else if (makeUpper.includes('FUJI')) {
                        if (modelUpper.includes('GFX')) {
                            sensorWidth = 43.8; // Medium format
                            cameraInfo = `${make} ${model} (Medium Format)`;
                        } else {
                            sensorWidth = 23.6; // APS-C Fuji
                            cameraInfo = `${make} ${model} (APS-C)`;
                        }
                    } else if (makeUpper.includes('OLYMPUS') || (makeUpper.includes('PANASONIC') && modelUpper.match(/\b(G[HX]?[0-9])\b/))) {
                        sensorWidth = 17.3; // Micro 4/3
                        cameraInfo = `${make} ${model} (Micro 4/3)`;
                    } else if (makeUpper.includes('PANASONIC') && modelUpper.match(/\b(S[15])\b/)) {
                        sensorWidth = 36; // Full frame Panasonic
                        cameraInfo = `${make} ${model} (Full Frame)`;
                    } else if (makeUpper.includes('PENTAX')) {
                        if (modelUpper.includes('K-1')) {
                            sensorWidth = 36; // Full frame
                            cameraInfo = `${make} ${model} (Full Frame)`;
                        } else {
                            sensorWidth = 23.6; // APS-C Pentax
                            cameraInfo = `${make} ${model} (APS-C)`;
                        }
                    }
                    
                    if (sensorWidth) {
                        console.log('Found by pattern matching. Sensor:', sensorWidth);
                    }
                }
            }
            // Check if it's a phone
            else if (make.match(/Apple|samsung|Google|Xiaomi|OnePlus|Huawei/i)) {
                // Try to get sensor from database
                const phoneSensors = PHONE_SENSORS[make]?.[model];
                
                if (phoneSensors && focalLength) {
                    // Guess which camera based on focal length
                    if (focalLength < 3) {
                        sensorWidth = phoneSensors.ultrawide || 5.7;
                        cameraInfo = `${make} ${model} (Ultra-wide)`;
                    } else if (focalLength < 10) {
                        sensorWidth = phoneSensors.main || 8.0;
                        cameraInfo = `${make} ${model} (Main)`;
                    } else {
                        sensorWidth = phoneSensors.tele || 4.0;
                        cameraInfo = `${make} ${model} (Telephoto)`;
                    }
                } else {
                    // Use defaults based on focal length patterns
                    if (focalLength < 3) {
                        sensorWidth = 5.7; // Typical ultrawide
                        cameraInfo = `${make} Phone (Ultra-wide, estimated)`;
                    } else if (focalLength < 10) {
                        sensorWidth = 8.0; // Typical main
                        cameraInfo = `${make} Phone (Main, estimated)`;
                    } else {
                        sensorWidth = 4.0; // Typical telephoto
                        cameraInfo = `${make} Phone (Telephoto, estimated)`;
                    }
                }
            }
            
            // Calculate FOV if we have sensor width and focal length
            if (sensorWidth && focalLength) {
                // Horizontal FOV in degrees
                fov = (2 * Math.atan(sensorWidth / (2 * focalLength)) * 180 / Math.PI).toFixed(1);
                detectedFieldOfView = parseFloat(fov);
                
                // Update UI
                document.getElementById('cameraType').textContent = cameraInfo;
                document.getElementById('detectedFOV').textContent = `${fov}¬∞ horizontal`;
                document.getElementById('fovOverride').value = Math.round(detectedFieldOfView);
                document.getElementById('fovInput').value = Math.round(detectedFieldOfView);
                
                // Update pixels per degree for blur calculations
                updatePixelsPerDegree();
                
                console.log('FOV calculated:', fov, 'degrees');
            } else if (focalLength35mm) {
                // Fallback: estimate from 35mm equivalent
                fov = estimateFOVFrom35mm(focalLength35mm);
                detectedFieldOfView = fov;
                
                document.getElementById('cameraType').textContent = `${make} ${model} (35mm equiv: ${focalLength35mm}mm)`;
                document.getElementById('detectedFOV').textContent = `~${fov}¬∞ horizontal (estimated)`;
                document.getElementById('fovOverride').value = Math.round(fov);
                document.getElementById('fovInput').value = Math.round(fov);
                
                updatePixelsPerDegree();
                
                console.log('FOV estimated from 35mm equiv:', fov, 'degrees');
            } else {
                document.getElementById('cameraType').textContent = 'Not detected - please set manually';
                document.getElementById('detectedFOV').textContent = 'Manual setting required';
                console.log('Could not detect camera or calculate FOV');
            }
        }

        // Estimate FOV from 35mm equivalent focal length
        function estimateFOVFrom35mm(focal35mm) {
            // Using 36mm sensor width for full frame
            return Math.round(2 * Math.atan(36 / (2 * focal35mm)) * 180 / Math.PI);
        }

        // Update pixels per degree based on detected or manual FOV
        function updatePixelsPerDegree() {
            if (originalCanvas && originalCanvas.width > 0) {
                const fov = parseFloat(document.getElementById('fovInput').value) || detectedFieldOfView;
                const pixelsPerDegree = originalCanvas.width / fov;
                
                // This will be used in the blur calculations
                window.currentPixelsPerDegree = pixelsPerDegree;
                
                // Update info display
                const infoBox = document.querySelector('.info-box');
                if (infoBox) {
                    const ppdSpan = document.createElement('span');
                    ppdSpan.innerHTML = `<p><strong>Pixels per Degree:</strong> <span>${pixelsPerDegree.toFixed(1)}</span></p>`;
                    // Add to existing info box content
                }
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            originalCanvas = document.getElementById('originalCanvas');
            simulatedCanvas = document.getElementById('simulatedCanvas');
            originalCtx = originalCanvas.getContext('2d');
            simulatedCtx = simulatedCanvas.getContext('2d');
            
            setupEventListeners();
            updateDisplayValues();
            
            // FOV override controls
            const fovSlider = document.getElementById('fovOverride');
            const fovInput = document.getElementById('fovInput');
            
            fovSlider.addEventListener('input', (e) => {
                fovInput.value = e.target.value;
                detectedFieldOfView = parseFloat(e.target.value);
                updatePixelsPerDegree();
                if (originalImage) {
                    applySimulation();
                }
            });
            
            fovInput.addEventListener('change', (e) => {
                const value = Math.max(10, Math.min(180, parseFloat(e.target.value) || 60));
                fovSlider.value = value;
                e.target.value = value;
                detectedFieldOfView = value;
                updatePixelsPerDegree();
                if (originalImage) {
                    applySimulation();
                }
            });
        });

        // Event Listeners
        function setupEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            // Slider updates
            document.getElementById('acuity').addEventListener('input', updateDisplayValues);
            document.getElementById('contrast').addEventListener('input', updateDisplayValues);
            document.getElementById('saturation').addEventListener('input', updateDisplayValues);
            document.getElementById('fieldLoss').addEventListener('input', updateDisplayValues);
            document.getElementById('condition').addEventListener('change', updateConditionPresets);
        }

        // File handling
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            // Extract EXIF data with better error handling
            EXIF.getData(file, function() {
                const exifData = EXIF.getAllTags(this);
                console.log('EXIF Data:', exifData); // Debug log
                
                // Show EXIF info in console for debugging
                if (exifData.Make) {
                    console.log('Camera Make:', exifData.Make);
                    console.log('Camera Model:', exifData.Model);
                    console.log('Focal Length:', exifData.FocalLength);
                    console.log('35mm Focal Length:', exifData.FocalLengthIn35mmFilm);
                    console.log('F-Stop:', exifData.FNumber);
                    console.log('ISO:', exifData.ISOSpeedRatings);
                }
                
                detectCameraAndFOV(exifData);
            });
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    displayOriginalImage();
                    applySimulation();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayOriginalImage() {
            if (!originalImage) return;
            
            // Limit size for performance
            const maxWidth = 1200;  // Increased for better quality
            const maxHeight = 900;   // Good balance of quality and performance
            
            let width = originalImage.width;
            let height = originalImage.height;
            
            if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width *= ratio;
                height *= ratio;
            }
            
            originalCanvas.width = width;
            originalCanvas.height = height;
            simulatedCanvas.width = width;
            simulatedCanvas.height = height;
            
            originalCtx.drawImage(originalImage, 0, 0, width, height);
        }

        // Vision simulation functions
        function applySimulation() {
            if (!originalImage) {
                alert('Please upload an image first');
                return;
            }
            
            showLoading(true);
            
            // Use setTimeout to ensure loading indicator appears
            setTimeout(() => {
                // Get parameters
                const logMAR = parseFloat(document.getElementById('acuity').value);
                const pelliRobson = parseFloat(document.getElementById('contrast').value);
                const saturation = parseFloat(document.getElementById('saturation').value) / 100;
                const fieldLoss = parseFloat(document.getElementById('fieldLoss').value) / 100;
                
                const yellowing = document.getElementById('yellowing').checked;
                const floaters = document.getElementById('floaters').checked;
                const centralScotoma = document.getElementById('centralScotoma').checked;
                
                // Copy original to simulated
                simulatedCtx.drawImage(originalCanvas, 0, 0);
                
                // Get image data
                let imageData = simulatedCtx.getImageData(0, 0, simulatedCanvas.width, simulatedCanvas.height);
                
                // Apply blur based on acuity
                if (logMAR > 0) {
                    imageData = applyAcuityBlur(imageData, logMAR, false);
                }
                
                // Apply contrast reduction
                if (pelliRobson < 2.0) {
                    imageData = applyContrastReduction(imageData, pelliRobson);
                }
                
                // Apply saturation reduction
                if (saturation < 1.0) {
                    imageData = applySaturationReduction(imageData, saturation);
                }
                
                // Apply condition-specific effects
                if (yellowing) {
                    imageData = applyYellowing(imageData);
                }
                
                if (floaters) {
                    imageData = applyFloaters(imageData);
                }
                
                if (centralScotoma) {
                    imageData = applyCentralScotoma(imageData);
                }
                
                if (fieldLoss > 0) {
                    imageData = applyPeripheralFieldLoss(imageData, fieldLoss);
                }
                
                // Put processed image back
                simulatedCtx.putImageData(imageData, 0, 0);
                
                showLoading(false);
            }, 10);
        }

        function applyAcuityBlur(imageData, logMAR, isFisheye) {
            // Calculate blur parameters based on Thompson et al. equations
            const FPN = 30; // Assumed peak sensitivity at 30 cycles/degree for normal vision
            const cyclesPerDegree = FPN * Math.pow(10, -logMAR);
            let sigma = 0.5 / cyclesPerDegree;
            
            // Use detected or manual FOV for pixel scaling
            const fov = detectedFieldOfView || 60;
            const pixelsPerDegree = imageData.width / fov;
            sigma *= pixelsPerDegree;
            
            // Apply Gaussian blur
            return gaussianBlur(imageData, sigma, isFisheye);
        }

        function gaussianBlur(imageData, sigma, isFisheye = false) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const output = new Uint8ClampedArray(data);
            
            // Limit sigma for performance
            sigma = Math.min(sigma, 20);
            
            // Create Gaussian kernel
            const kernelSize = Math.min(Math.ceil(sigma * 3) * 2 + 1, 31); // Cap kernel size
            const kernel = createGaussianKernel(sigma);
            
            // If fisheye, apply radially-varying blur
            if (isFisheye) {
                const centerX = width / 2;
                const centerY = height / 2;
                const maxRadius = Math.min(width, height) / 2;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const radius = Math.sqrt(dx * dx + dy * dy);
                        const angle = 2 * Math.asin(Math.min(1, radius / (2 * maxRadius)));
                        const localSigma = sigma * (1 + angle / (Math.PI / 2) * 0.5);
                        
                        applyLocalBlur(data, output, x, y, width, height, localSigma);
                    }
                }
            } else {
                // Apply uniform blur
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        applyLocalBlur(data, output, x, y, width, height, sigma);
                    }
                }
            }
            
            imageData.data.set(output);
            return imageData;
        }

        function createGaussianKernel(sigma) {
            const size = Math.min(Math.ceil(sigma * 3) * 2 + 1, 31); // Cap size for performance
            const kernel = [];
            const center = Math.floor(size / 2);
            let sum = 0;
            
            for (let i = 0; i < size; i++) {
                kernel[i] = [];
                for (let j = 0; j < size; j++) {
                    const x = i - center;
                    const y = j - center;
                    const value = Math.exp(-(x * x + y * y) / (2 * sigma * sigma));
                    kernel[i][j] = value;
                    sum += value;
                }
            }
            
            // Normalize
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    kernel[i][j] /= sum;
                }
            }
            
            return kernel;
        }

        function applyLocalBlur(input, output, x, y, width, height, sigma) {
            const kernelSize = Math.min(Math.ceil(sigma * 3) * 2 + 1, 31); // Cap size
            const halfSize = Math.floor(kernelSize / 2);
            const kernel = createGaussianKernel(sigma);
            
            let r = 0, g = 0, b = 0;
            let weightSum = 0;
            
            for (let ky = -halfSize; ky <= halfSize; ky++) {
                for (let kx = -halfSize; kx <= halfSize; kx++) {
                    const px = Math.min(Math.max(x + kx, 0), width - 1);
                    const py = Math.min(Math.max(y + ky, 0), height - 1);
                    const idx = (py * width + px) * 4;
                    const weight = kernel[ky + halfSize][kx + halfSize];
                    
                    r += input[idx] * weight;
                    g += input[idx + 1] * weight;
                    b += input[idx + 2] * weight;
                    weightSum += weight;
                }
            }
            
            const outputIdx = (y * width + x) * 4;
            output[outputIdx] = r / weightSum;
            output[outputIdx + 1] = g / weightSum;
            output[outputIdx + 2] = b / weightSum;
            output[outputIdx + 3] = input[outputIdx + 3];
        }

        function applyContrastReduction(imageData, pelliRobson) {
            const data = imageData.data;
            const factor = pelliRobson / 2.0; // Normalize to 0-1
            
            // Calculate mean luminance
            let meanLum = 0;
            for (let i = 0; i < data.length; i += 4) {
                meanLum += 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            meanLum /= (data.length / 4);
            
            // Apply contrast reduction
            for (let i = 0; i < data.length; i += 4) {
                data[i] = meanLum + (data[i] - meanLum) * factor;
                data[i + 1] = meanLum + (data[i + 1] - meanLum) * factor;
                data[i + 2] = meanLum + (data[i + 2] - meanLum) * factor;
            }
            
            return imageData;
        }

        function applySaturationReduction(imageData, saturation) {
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Convert to grayscale
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                
                // Mix with original based on saturation
                data[i] = gray + (r - gray) * saturation;
                data[i + 1] = gray + (g - gray) * saturation;
                data[i + 2] = gray + (b - gray) * saturation;
            }
            
            return imageData;
        }

        function applyYellowing(imageData) {
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                // Reduce blue channel to create yellowing effect
                data[i + 2] *= 0.7;
                // Slightly boost red
                data[i] = Math.min(255, data[i] * 1.1);
            }
            
            return imageData;
        }

        function applyFloaters(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            // Add random dark spots
            const numFloaters = Math.floor(Math.random() * 10) + 5;
            
            for (let f = 0; f < numFloaters; f++) {
                const x = Math.floor(Math.random() * width);
                const y = Math.floor(Math.random() * height);
                const size = Math.floor(Math.random() * 5) + 2;
                
                for (let dy = -size; dy <= size; dy++) {
                    for (let dx = -size; dx <= size; dx++) {
                        const px = Math.min(Math.max(x + dx, 0), width - 1);
                        const py = Math.min(Math.max(y + dy, 0), height - 1);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist <= size) {
                            const idx = (py * width + px) * 4;
                            const darkness = 1 - (dist / size) * 0.5;
                            data[idx] *= darkness * 0.3;
                            data[idx + 1] *= darkness * 0.3;
                            data[idx + 2] *= darkness * 0.3;
                        }
                    }
                }
            }
            
            return imageData;
        }

        function applyCentralScotoma(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.15;
            const feather = radius * 0.5;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius + feather) {
                        const idx = (y * width + x) * 4;
                        let factor = 1;
                        
                        if (dist < radius) {
                            factor = 0;
                        } else {
                            factor = (dist - radius) / feather;
                        }
                        
                        data[idx] *= factor;
                        data[idx + 1] *= factor;
                        data[idx + 2] *= factor;
                    }
                }
            }
            
            return imageData;
        }

        function applyPeripheralFieldLoss(imageData, amount) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2;
            const innerRadius = maxRadius * (1 - amount);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > innerRadius) {
                        const idx = (y * width + x) * 4;
                        const factor = Math.max(0, 1 - (dist - innerRadius) / (maxRadius - innerRadius));
                        
                        data[idx] *= factor;
                        data[idx + 1] *= factor;
                        data[idx + 2] *= factor;
                    }
                }
            }
            
            return imageData;
        }

        // UI update functions
        function updateDisplayValues() {
            const logMAR = parseFloat(document.getElementById('acuity').value);
            const snellen = logMARToSnellen(logMAR);
            const cyclesPerDegree = 30 * Math.pow(10, -logMAR);
            const sigma = 0.5 / cyclesPerDegree;
            
            // Calculate pixel-based sigma (assuming 800px width = 60 degree FOV)
            const pixelSigma = sigma * (800 / 60);
            
            document.getElementById('acuityValue').textContent = snellen;
            document.getElementById('contrastValue').textContent = document.getElementById('contrast').value;
            document.getElementById('saturationValue').textContent = document.getElementById('saturation').value + '%';
            document.getElementById('fieldLossValue').textContent = document.getElementById('fieldLoss').value + '%';
            
            document.getElementById('logmarInfo').textContent = logMAR.toFixed(2);
            document.getElementById('cpdInfo').textContent = cyclesPerDegree.toFixed(2);
            document.getElementById('sigmaInfo').textContent = pixelSigma.toFixed(1);
        }

        function logMARToSnellen(logMAR) {
            const denominator = Math.round(20 * Math.pow(10, logMAR));
            return `20/${denominator}`;
        }

        function updateConditionPresets() {
            const condition = document.getElementById('condition').value;
            
            const presets = {
                acuity: { logMAR: 0.5, contrast: 1.5, saturation: 100, yellowing: false, floaters: false, scotoma: false, field: 0 },
                cataracts: { logMAR: 0.3, contrast: 1.2, saturation: 80, yellowing: true, floaters: false, scotoma: false, field: 0 },
                diabetic: { logMAR: 0.4, contrast: 1.3, saturation: 90, yellowing: false, floaters: true, scotoma: false, field: 10 },
                macular: { logMAR: 0.6, contrast: 1.0, saturation: 70, yellowing: false, floaters: false, scotoma: true, field: 0 },
                glaucoma: { logMAR: 0.2, contrast: 1.4, saturation: 100, yellowing: false, floaters: false, scotoma: false, field: 40 },
                custom: null
            };
            
            const preset = presets[condition];
            if (preset) {
                document.getElementById('acuity').value = preset.logMAR;
                document.getElementById('contrast').value = preset.contrast;
                document.getElementById('saturation').value = preset.saturation;
                document.getElementById('fieldLoss').value = preset.field;
                document.getElementById('yellowing').checked = preset.yellowing;
                document.getElementById('floaters').checked = preset.floaters;
                document.getElementById('centralScotoma').checked = preset.scotoma;
                
                updateDisplayValues();
                
                if (originalImage) {
                    applySimulation();
                }
            }
        }

        function resetImage() {
            if (originalImage) {
                simulatedCtx.drawImage(originalCanvas, 0, 0);
            }
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'vision_simulation.png';
            link.href = simulatedCanvas.toDataURL();
            link.click();
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
    </script>
</body>
</html>