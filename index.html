<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Seeing Home Through Older Eyes — CSF Prototype v3</title>
  <style>
  *{box-sizing:border-box}body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;margin:0;color:#111;background:#fafafa}
  header{padding:24px 16px;background:#fff;border-bottom:1px solid #eee}
  h1{margin:0 0 8px 0;font-size:22px}
  main{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px}
  .panel{background:#fff;border:1px solid #eee;border-radius:16px;padding:16px}
  summary{cursor:pointer}
  .tool-row{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
  .tool{flex:1 1 160px;background:#f9f9f9;border:1px solid #eee;border-radius:12px;padding:12px}
  .button{display:inline-block;background:#111;color:#fff;border:none;border-radius:12px;padding:8px 12px;cursor:pointer}
  .button.secondary{background:#444}
  .viewer{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  canvas{max-width:100%;width:100%;background:#ddd;border-radius:8px}
  label{display:block;margin:6px 0}
  small{display:block;color:#555}
  .uploader{border:2px dashed #bbb;border-radius:12px;padding:16px;text-align:center;background:#fbfbfb}
  .uploader.dragover{background:#eef7ff;border-color:#339}
  #fileInput{display:none}
  #status{margin-top:10px;font-size:0.95rem;color:#333;white-space:pre-wrap}
  .perf{background:#fff;border:1px dashed #ddd;border-radius:12px;padding:12px;margin-top:12px}
  </style>
</head>
<body>
  <header>
    <h1>Seeing Home Through Older Eyes — CSF-based Prototype (v3)</h1>
    <p>Upload a photo or render. All processing runs locally in your browser.</p>
  </header>

  <main>
    <section class="panel">
      <div class="uploader" id="dropArea" aria-label="Drop image here">
        <p><strong>Drop image here</strong> or <label for="fileInput" class="button">Choose a file</label></p>
        <input id="fileInput" type="file" accept="image/*"/>
        <small>PNG/JPG recommended • Large images are auto-downscaled for performance</small>
      </div>

      <div class="perf">
        <label for="maxPixels">Max processing size: <span id="maxPixelsLabel">3 MP</span></label>
        <input id="maxPixels" type="range" min="1" max="8" step="1" value="3"/>
        <small>Higher = sharper but slower. The cap is applied at load time.</small>
      </div>

      <details open>
        <summary><strong>CSF Visibility Model (prototype)</strong></summary>
        <div class="tool-row">
          <div class="tool">
            <h3>Acuity (logMAR)</h3>
            <label>logMAR: <span id="logmarVal">0.60</span> &nbsp; Snellen: <span id="snellen">~20/80</span></label>
            <input id="logmar" type="range" min="0" max="1.0" step="0.05" value="0.60"/>
          </div>
          <div class="tool">
            <h3>Contrast (Pelli–Robson)</h3>
            <label>PR: <span id="prVal">1.40</span></label>
            <input id="pr" type="range" min="0.0" max="2.0" step="0.05" value="1.40"/>
          </div>
        </div>
        <div class="tool-row">
          <div class="tool">
            <h3>Model Settings</h3>
            <label>Levels: <span id="levelsVal">4</span></label>
            <input id="levels" type="range" min="3" max="6" step="1" value="4"/>
            <label>Strength: <span id="strengthVal">1.00</span></label>
            <input id="strength" type="range" min="0.0" max="1.0" step="0.05" value="1.00"/>
            <button id="applyCSF" class="button secondary">Apply CSF Filter</button>
          </div>
        </div>
        <small id="csfInfo"></small>
      </details>

      <details>
        <summary><strong>Acuity & Edges (demos)</strong></summary>
        <div class="tool-row">
          <div class="tool">
            <h3>Gaussian blur (px)</h3>
            <label>σ: <span id="blurVal">3</span></label>
            <input id="blur" type="range" min="0" max="15" step="0.5" value="3"/>
            <button id="applyBlur" class="button secondary">Apply Blur</button>
          </div>
          <div class="tool">
            <h3>Canny edges</h3>
            <label>T1 <input id="canny1" type="number" min="0" max="255" value="80"/></label>
            <label>T2 <input id="canny2" type="number" min="0" max="255" value="160"/></label>
            <button id="applyCanny" class="button secondary">Run Edges</button>
          </div>
        </div>
      </details>

      <details>
        <summary><strong>Lens & Field Effects</strong></summary>
        <div class="tool-row">
          <div class="tool">
            <h3>Lens yellowing</h3>
            <label>Intensity: <span id="yellowVal">60%</span></label>
            <input id="yellow" type="range" min="0" max="100" step="5" value="60"/>
            <button id="applyYellow" class="button secondary">Apply Yellowing</button>
          </div>
          <div class="tool">
            <h3>Global contrast</h3>
            <label>Reduce: <span id="contrastVal">15%</span></label>
            <input id="contrast" type="range" min="0" max="50" step="5" value="15"/>
            <button id="applyContrast" class="button secondary">Reduce Contrast</button>
          </div>
          <div class="tool">
            <h3>Central scotoma</h3>
            <label>Radius (% min dim): <span id="scSizeVal">15%</span></label>
            <input id="scSize" type="range" min="0" max="40" step="1" value="15"/>
            <label>Feather (px): <span id="scFeatherVal">40</span></label>
            <input id="scFeather" type="range" min="0" max="100" step="5" value="40"/>
            <button id="applyScotoma" class="button secondary">Apply Scotoma</button>
          </div>
        </div>
      </details>

      <div class="tool-row" style="margin-top:12px">
        <div class="tool">
          <h3>Reset & Download</h3>
          <button id="reset" class="button">Reset to Original</button>
          <button id="download" class="button">Download Processed</button>
        </div>
      </div>

      <div id="status" role="status" aria-live="polite"></div>
    </section>

    <section class="viewer">
      <div class="panel">
        <h2>Original</h2>
        <canvas id="orig"></canvas>
      </div>
      <div class="panel">
        <h2>Processed</h2>
        <canvas id="proc"></canvas>
      </div>
    </section>
  </main>

  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="cv['onRuntimeInitialized']=onCvReady;"></script>
  <script>
  let origMat=null, procMat=null, origCanvas=null, procCanvas=null, statusEl=null;
  let maxPixels=3_000_000;

  function setStatus(msg){ statusEl.textContent = msg || ''; }
  function snellenFromLogMAR(v){ return '~20/' + Math.round(20*Math.pow(10,v)); }
  function onCvReady(){ setStatus('OpenCV.js is ready.'); }

  function fitCanvasToImage(canvas,w,h){
    const px=w*h;
    if(px>maxPixels){ const s=Math.sqrt(maxPixels/px); w=Math.round(w*s); h=Math.round(h*s); }
    canvas.width=w; canvas.height=h;
  }

  function loadImage(file){
    return new Promise((resolve,reject)=>{
      if(!file || !file.type.startsWith('image/')) return reject(new Error('Please choose an image file.'));
      const img=new Image(); img.onload=()=>resolve(img); img.onerror=()=>reject(new Error('Could not read image.')); img.src=URL.createObjectURL(file);
    });
  }

  async function handleFile(file){
    try{
      setStatus('Loading image...');
      const img=await loadImage(file);
      fitCanvasToImage(origCanvas, img.width, img.height);
      const ctx=origCanvas.getContext('2d'); ctx.clearRect(0,0,origCanvas.width,origCanvas.height); ctx.drawImage(img,0,0,origCanvas.width,origCanvas.height);
      if(origMat) origMat.delete(); if(procMat) procMat.delete();
      origMat = cv.matFromImageData(ctx.getImageData(0,0,origCanvas.width,origCanvas.height));
      procMat = origMat.clone();
      cv.imshow('proc', procMat);
      setStatus(`Loaded ${file.name} (${img.width}×${img.height} → ${origCanvas.width}×${origCanvas.height})`);
    }catch(e){ setStatus(e.message||'Failed to load image.'); }
  }

  function resetProcessed(){ if(!origMat) return; if(procMat) procMat.delete(); procMat=origMat.clone(); cv.imshow('proc', procMat); setStatus('Reset.'); }

  // ---------- CSF float pipeline ----------
  function toYCrCb(mat){ const ycc=new cv.Mat(); cv.cvtColor(mat,ycc,cv.COLOR_RGBA2YCrCb,0); return ycc; }
  function fromYCrCb(ycc){ const out=new cv.Mat(); cv.cvtColor(ycc,out,cv.COLOR_YCrCb2RGBA,0); return out; }
  function split3(m){ const mv=new cv.MatVector(); cv.split(m,mv); return {Y:mv.get(0),Cr:mv.get(1),Cb:mv.get(2),mv}; }
  function merge3(a,b,c){ const mv=new cv.MatVector(); mv.push_back(a); mv.push_back(b); mv.push_back(c); const out=new cv.Mat(); cv.merge(mv,out); mv.delete(); return out; }

  function pyrBuildLaplacian32(gray32, levels){
    const gP=[], lP=[];
    let cur=gray32.clone();
    for(let i=0;i<levels;i++){
      const down=new cv.Mat(); cv.pyrDown(cur,down);
      const up=new cv.Mat(); cv.pyrUp(down,up,cur.size());
      const lap=new cv.Mat(); cv.subtract(cur,up,lap);
      gP.push(cur); lP.push(lap);
      cur=down; up.delete();
    }
    gP.push(cur);
    return {gP,lP};
  }
  function pyrReconstruct32(lP, low){
    let cur=low.clone();
    for(let i=lP.length-1;i>=0;i--){
      const up=new cv.Mat(); cv.pyrUp(cur,up,lP[i].size());
      const sum=new cv.Mat(); cv.add(up,lP[i],sum);
      cur.delete(); cur=sum; up.delete();
    }
    return cur;
  }

  function baseCSF(f){ const beta=2.2; return f*Math.exp(-beta*f); }
  function csfGainBand(i,total,logMAR,PR){
    const f=(i+1)/total;
    const aShift=1/(1+2.5*logMAR);
    const cShift=Math.pow(10, PR-2);
    const ref=baseCSF(f);
    const test=cShift*baseCSF(Math.max(1e-3,f*aShift));
    const gain=Math.min(1,Math.max(0,test/Math.max(1e-6,ref)));
    return gain;
  }

  function applyCSF(logMAR, PR, levels, strength){
    if(!procMat) { setStatus('Load an image first.'); return; }
    const ycc=toYCrCb(procMat);
    const {Y,Cr,Cb,mv}=split3(ycc);
    const Y32=new cv.Mat(); Y.convertTo(Y32, cv.CV_32F, 1/255.0);

    const pyr=pyrBuildLaplacian32(Y32, levels);
    let gains=[];
    for(let i=0;i<pyr.lP.length;i++){
      const gain=csfGainBand(i, pyr.lP.length+1, logMAR, PR);
      gains.push(gain.toFixed(2));
      const g=(1-strength)+strength*gain;
      cv.multiply(pyr.lP[i], new cv.Scalar(g), pyr.lP[i]); // scalar multiply
    }
    const cShift=Math.min(1, Math.max(0.2, Math.pow(10, PR-2)));
    cv.multiply(pyr.gP[pyr.gP.length-1], new cv.Scalar(cShift), pyr.gP[pyr.gP.length-1]);

    const Yrec=pyrReconstruct32(pyr.lP, pyr.gP[pyr.gP.length-1]);
    cv.min(Yrec, new cv.Scalar(1), Yrec); cv.max(Yrec, new cv.Scalar(0), Yrec);
    const Y8=new cv.Mat(); Yrec.convertTo(Y8, cv.CV_8U, 255.0);

    const yccOut=merge3(Y8, Cr, Cb);
    const rgba=fromYCrCb(yccOut);
    procMat.delete(); procMat=rgba; cv.imshow('proc', procMat);

    // cleanup
    ycc.delete(); mv.delete(); Y.delete(); Cr.delete(); Cb.delete(); Y32.delete();
    pyr.gP.forEach(m=>m.delete()); pyr.lP.forEach(m=>m.delete()); Yrec.delete(); Y8.delete(); yccOut.delete();

    document.getElementById('csfInfo').textContent = `Band gains: [${gains.join(', ')}] • Lowpass scale: ${cShift.toFixed(2)}`;
  }

  // ---------- Other effects ----------
  function applyBlur(px){ if(!procMat) return; const out=new cv.Mat(); const k=Math.max(1,(Math.floor(px)|1));
    cv.GaussianBlur(procMat,out,new cv.Size(k,k),0,0,cv.BORDER_DEFAULT); procMat.delete(); procMat=out; cv.imshow('proc', procMat); }
  function applyCanny(t1,t2){ if(!procMat) return; const gray=new cv.Mat(); cv.cvtColor(procMat,gray,cv.COLOR_RGBA2GRAY,0);
    const edges=new cv.Mat(); cv.Canny(gray,edges,Number(t1),Number(t2),3,false);
    const disp=new cv.Mat(); cv.cvtColor(edges,disp,cv.COLOR_GRAY2RGBA,0); procMat.delete(); procMat=disp; cv.imshow('proc', procMat); gray.delete(); edges.delete(); }
  function applyYellow(intensity){
    if(!procMat) return;
    const a=Math.max(0,Math.min(1,intensity/100));
    const mv=new cv.MatVector(); cv.split(procMat,mv);
    const R=mv.get(0), G=mv.get(1), B=mv.get(2), A=(mv.size()>=4? mv.get(3): null);
    let Rf=new cv.Mat(); R.convertTo(Rf,cv.CV_32F);
    let Gf=new cv.Mat(); G.convertTo(Gf,cv.CV_32F);
    let Bf=new cv.Mat(); B.convertTo(Bf,cv.CV_32F);
    const up=1+0.6*a, down=1-0.8*a;
    cv.multiply(Rf,new cv.Scalar(up),Rf);
    cv.multiply(Gf,new cv.Scalar(up),Gf);
    cv.multiply(Bf,new cv.Scalar(down),Bf);
    cv.min(Rf,new cv.Scalar(255),Rf); cv.max(Rf,new cv.Scalar(0),Rf);
    cv.min(Gf,new cv.Scalar(255),Gf); cv.max(Gf,new cv.Scalar(0),Gf);
    cv.min(Bf,new cv.Scalar(255),Bf); cv.max(Bf,new cv.Scalar(0),Bf);
    Rf.convertTo(R,cv.CV_8U); Gf.convertTo(G,cv.CV_8U); Bf.convertTo(B,cv.CV_8U);
    const mv2=new cv.MatVector(); mv2.push_back(R); mv2.push_back(G); mv2.push_back(B);
    if(A){ mv2.push_back(A); }
    const merged=new cv.Mat(); cv.merge(mv2, merged);
    procMat.delete(); procMat=merged; cv.imshow('proc', procMat);
    // cleanup
    R.delete(); G.delete(); B.delete(); Rf.delete(); Gf.delete(); Bf.delete(); mv.delete(); mv2.delete(); if(A) A.delete();
  }
  function applyContrast(percent){ if(!procMat) return; const a=Math.max(0,Math.min(1,percent/100));
    const out=new cv.Mat(procMat.rows,procMat.cols,procMat.type()); const mid=new cv.Mat(procMat.rows,procMat.cols,procMat.type(),[128,128,128,255]);
    cv.addWeighted(procMat,1-a,mid,a,0,out); procMat.delete(); procMat=out; cv.imshow('proc', procMat); mid.delete(); }
  function applyScotoma(sizePct,featherPx){ if(!procMat) return; const w=procMat.cols,h=procMat.rows; const r=Math.round(Math.min(w,h)*(sizePct/100)); const cx=Math.round(w/2),cy=Math.round(h/2);
    const mask=cv.Mat.zeros(h,w,cv.CV_8UC1); cv.circle(mask,new cv.Point(cx,cy),r,new cv.Scalar(255),-1);
    if(featherPx>0){ const k=Math.max(1,(featherPx|1)); cv.GaussianBlur(mask,mask,new cv.Size(k,k),0,0,cv.BORDER_DEFAULT); }
    const black=cv.Mat.zeros(h,w,procMat.type()); const inv=new cv.Mat(); cv.bitwise_not(mask,inv);
    const fg=new cv.Mat(),bg=new cv.Mat(),res=new cv.Mat(); cv.bitwise_and(procMat,procMat,fg,inv); cv.bitwise_and(black,black,bg,mask); cv.add(fg,bg,res);
    procMat.delete(); procMat=res; cv.imshow('proc', procMat); mask.delete(); black.delete(); inv.delete(); fg.delete(); bg.delete(); }

  // ---------- Wiring ----------
  window.addEventListener('DOMContentLoaded',()=>{
    origCanvas=document.getElementById('orig'); procCanvas=document.getElementById('proc'); statusEl=document.getElementById('status');

    const fileInput=document.getElementById('fileInput'); const dropArea=document.getElementById('dropArea');
    const maxPixelsRange=document.getElementById('maxPixels'); const maxPixelsLabel=document.getElementById('maxPixelsLabel');
    function updateCap(){ maxPixels=Number(maxPixelsRange.value)*1_000_000; maxPixelsLabel.textContent=`${maxPixelsRange.value} MP`; } updateCap();
    maxPixelsRange.addEventListener('input', updateCap);

    fileInput.addEventListener('change', e=>{ const f=e.target.files[0]; if(f) handleFile(f); });
    ['dragenter','dragover','dragleave','drop'].forEach(evt=>dropArea.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); }, false));
    ['dragenter','dragover'].forEach(evt=>dropArea.addEventListener(evt, ()=>dropArea.classList.add('dragover'), false));
    ['dragleave','drop'].forEach(evt=>dropArea.addEventListener(evt, ()=>dropArea.classList.remove('dragover'), false));
    dropArea.addEventListener('drop', e=>{ const f=e.dataTransfer.files && e.dataTransfer.files[0]; if(f) handleFile(f); });

    const logmar=document.getElementById('logmar'), logmarVal=document.getElementById('logmarVal'), snellen=document.getElementById('snellen');
    const pr=document.getElementById('pr'), prVal=document.getElementById('prVal');
    const levels=document.getElementById('levels'), levelsVal=document.getElementById('levelsVal');
    const strength=document.getElementById('strength'), strengthVal=document.getElementById('strengthVal');
    const applyCSFBtn=document.getElementById('applyCSF');

    function labels(){ const lv=Number(logmar.value); logmarVal.textContent=lv.toFixed(2); snellen.textContent=snellenFromLogMAR(lv);
                       prVal.textContent=Number(pr.value).toFixed(2); levelsVal.textContent=levels.value; strengthVal.textContent=Number(strength.value).toFixed(2); }
    labels(); [logmar,pr,levels,strength].forEach(el=>el.addEventListener('input', labels));

    applyCSFBtn.addEventListener('click', ()=>applyCSF(Number(logmar.value), Number(pr.value), Number(levels.value), Number(strength.value)));

    const blur=document.getElementById('blur'), blurVal=document.getElementById('blurVal'); document.getElementById('applyBlur').addEventListener('click', ()=>applyBlur(Number(blur.value)));
    blur.addEventListener('input', ()=>{ blurVal.textContent=blur.value; });

    const canny1=document.getElementById('canny1'), canny2=document.getElementById('canny2'); document.getElementById('applyCanny').addEventListener('click', ()=>applyCanny(Number(canny1.value), Number(canny2.value)));

    const yellow=document.getElementById('yellow'), yellowVal=document.getElementById('yellowVal'); document.getElementById('applyYellow').addEventListener('click', ()=>applyYellow(Number(yellow.value)));
    yellow.addEventListener('input', ()=>{ yellowVal.textContent=yellow.value+'%'; });

    const contrast=document.getElementById('contrast'), contrastVal=document.getElementById('contrastVal'); document.getElementById('applyContrast').addEventListener('click', ()=>applyContrast(Number(contrast.value)));
    contrast.addEventListener('input', ()=>{ contrastVal.textContent=contrast.value+'%'; });

    const scSize=document.getElementById('scSize'), scSizeVal=document.getElementById('scSizeVal');
    const scFeather=document.getElementById('scFeather'), scFeatherVal=document.getElementById('scFeatherVal');
    document.getElementById('applyScotoma').addEventListener('click', ()=>applyScotoma(Number(scSize.value), Number(scFeather.value)));
    scSize.addEventListener('input', ()=>{ scSizeVal.textContent=scSize.value+'%'; });
    scFeather.addEventListener('input', ()=>{ scFeatherVal.textContent=scFeather.value; });

    document.getElementById('reset').addEventListener('click', resetProcessed);
    document.getElementById('download').addEventListener('click', ()=>{ const link=document.createElement('a'); link.download='processed.png'; link.href=proc.toDataURL('image/png'); link.click(); });
  });
  </script>
</body>
</html>
